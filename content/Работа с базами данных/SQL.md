+++
title = 'SQL'
weight = 2
bookFlatSection = true
+++

## SQL

#### 1. Что такое транзакции?
Это набор логически связанных запросов. Транзакция либо выполнится полностью(**commit**), либо откатится(**rollback**)

--- 
#### 2. Расскажите про ACID
Это набор свойств, гарантирующих надежность транзакции:
- **A** - Атомарность. Все операции внутри транзакции либо выполняются полностью, либо не выполняются вообще
- **C** - Согласованность. После выполнения транзакции данные должны соблюдать все правила целостности (правила целостности определяются бизнес-логикой)
- **I** - Изолированность. Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на ее результат 
- **D** - Долговечность. Независимо от проблем (потеря питания, сбой и т.д), изменения, сделанные успешно завершенной транзакцией, должны остаться сохранёнными в базе данных    

---
#### 3. Проблемы параллельных транзакций
- *Потерянное обновление*. При одновременном изменении одних и тех же данных разными транзакциями - в силу вступают только изменения в последней транзакции(***Rapeatable read, и все что выше***)
- *Грязное чтение*. Транзакция **A** обновляет значение в базе данных, но еще не закоммитила их. Транзакция **B** считывает это значение, не зная, что изменения могут быть отменены. Если транзакция **A** отменяется, значение, прочитанное транзакцией **B**, было "грязным", так как оно не отражает окончательное состояние базы данных (***Read commited, и всё что выше***)
- *Неповторяющееся чтение*. **Возникает в результате изменения самих данных!** Транзакция **A** читает значение **X** из базы данных. Транзакция **B** обновляет значение **X** и фиксирует изменения. Транзакция **A** повторно читает значение **X**, но теперь оно изменено транзакцией **B** (***Repeatable read и всё что выше***)
- *Фантомное чтение*. **Возникает в результате изменения кол-ва данных!** Транзакция **A** выполняет запрос на выборку всех записей. Транзакция **B** добавляет запись и фиксирует изменения. Транзакция **A** снова выполняет тот же запрос, и теперь результат включает новую запись, которая была добавлена транзакцией **B** (***Serializable***)

---
#### 4. Уровни изолированности (read uncommitted, read committed, repeatable read, serializable)
Перечислил от менее строгого - к самому строгому
- **Read uncommited**. Транзакции могут читать данные, которые еще не зафиксированы другими транзакциями (использовать, когда все транзакции на чтение)
- **Read commited**. Транзакции могут читать только те данные, которые уже зафиксированы другими данными (решает **грязное чтение**)
- **Repeatable read**. В пределах одной транзакции, если вы дважды запрашиваете одну и ту же запись, то независимо от изменений, сделанных другими транзакциями, данные не изменятся. (решает **грязное** и **неповторяющееся чтение** и **потерянное обновление**)
- **Serializable**. Самый строгий уровень изоляции. Транзакции выполняются так, как будто происходят последовательно, одна за другой (**решает всё, но бьет по производительности**)

---
***Какой уровень изолированности стоит по умолчанию в MySQL?***

Repeatable read

---
***Зависимость скорости работы БД и уровня изоляции***

|Уровень изоляции|Описание|Влияние на производительность|
|---|---|---|
|Read Uncommitted|Транзакции могут читать данные, которые ещё не зафиксированы.|Самый быстрый, но данные могут быть неконсистентными.|
|Read Committed|Транзакции читают только зафиксированные данные.|Средняя производительность, баланс между скоростью и консистентностью.|
|Repeatable Read|Гарантирует, что данные, прочитанные транзакцией, не изменятся, пока транзакция не завершена.|Снижает производительность из-за блокировок, но обеспечивает более высокую консистентность.|
|Serializable|Самый высокий уровень изоляции, предотвращает все виды аномалий.|Самый медленный, так как использует полные блокировки.|

---
#### 5. Виды JOIN. Как работает каждый JOIN?
Это такой оператор, позволяющий связать данные из двух таблиц. Бывают:
- *INNER JOIN*. Выдаст общее для левой и правой таблицы
- *LEFT JOIN*. Выдаст все значения с левой таблицы и все подходящие с правой
- *RIGHT JOIN*. Выдаст все значения с правой таблицы и все подходящие с левой
- *FULL JOIN*. Все записи, которые присутствуют в таблицах
- *CROSS JOIN*. Создаст декартово произведение двух таблиц (если в первой таблице 5 строк, а во второй 3, то вернет 5 x 3 = 15)
- *NATURAL JOIN*. Объединяет таблицы по столбцам с одинаковыми именами, если значения в этих столбцах совпадают
- *SELF JOIN*. Соединяет таблицы с самой собой

---
***Как реализовать JOIN?***


**INNER JOIN**

Возвращает только те строки, которые совпадают в обеих таблицах.

```sql
SELECT employees.name, departments.name AS department_name
FROM employees
INNER JOIN departments ON employees.department_id = departments.id;
```

**Результат:** Только сотрудники, у которых есть совпадающий отдел.

---

**LEFT JOIN (LEFT OUTER JOIN)**

Возвращает все строки из левой таблицы и совпадающие строки из правой таблицы. Если совпадения нет, то в правых колонках будет `NULL`.

```sql
SELECT employees.name, departments.name AS department_name
FROM employees
LEFT JOIN departments ON employees.department_id = departments.id;
```

**Результат:** Все сотрудники, даже если они не привязаны к отделу.

---

**RIGHT JOIN (RIGHT OUTER JOIN)**

Возвращает все строки из правой таблицы и совпадающие строки из левой таблицы. Если совпадения нет, то в левых колонках будет `NULL`.

```sql
SELECT employees.name, departments.name AS department_name
FROM employees
RIGHT JOIN departments ON employees.department_id = departments.id;
```

**Результат:** Все отделы, даже если в них нет сотрудников.

---

**FULL JOIN (FULL OUTER JOIN)**

Возвращает все строки из обеих таблиц. Если совпадений нет, в соответствующих колонках будет `NULL`.

```sql
SELECT employees.name, departments.name AS department_name
FROM employees
FULL JOIN departments ON employees.department_id = departments.id;
```

**Результат:** Все сотрудники и все отделы, включая несвязанные.

---

**CROSS JOIN**

Возвращает декартово произведение таблиц (каждая строка из первой таблицы объединяется с каждой строкой из второй таблицы).

```sql
SELECT employees.name, departments.name AS department_name
FROM employees
CROSS JOIN departments;
```

**Результат:** Все возможные комбинации сотрудников и отделов.

---

**SELF JOIN**

Применяется для объединения таблицы самой с собой.

```sql
SELECT e1.name AS employee1, e2.name AS manager
FROM employees e1
INNER JOIN employees e2 ON e1.manager_id = e2.id;
```

**Результат:** Список сотрудников и их менеджеров.

---
#### 6. Индексы в SQL. Что это? 
Индекс это ключ, построенный из одного или нескольких столбцов в базе данных, который ускоряет выборку. При этом, чем больше дубликатов в столбце - тем хуже работает индекс.

---
***Плюсы и минусы индексов***

**Плюсы:**
- Улучшают производительность для select и сортировки по определенным полям

**Минусы:**
- Ухудшается производительность, когда нужно вставлять, обновлять или удалять данные
- Требуется дополнительное место и чем больше/длиннее ключ - тем больше размер индекса

---
***Какие виды индексов знаешь?***

|Тип индекса|Описание|Использование|
|---|---|---|
|B-дерево (B-tree)|Стандартный индекс, используемый в большинстве СУБД. Данные хранятся в сбалансированном дереве.|Для поиска, сортировки, диапазонных запросов.|
|Индекс с несколькими столбцами (Composite Index)|Индекс, включающий несколько столбцов. Ускоряет запросы, использующие несколько фильтров.|Когда запросы фильтруют по нескольким столбцам одновременно.|
|Индекс полного текста (Full-Text Index)|Индекс для быстрого поиска по тексту, включая ключевые слова и фразы.|Поиск по длинным текстовым полям, например, в статьях или документах.|
|Хеш-индекс (Hash Index)|Использует хеш-функцию для поиска точных совпадений.|Для быстрого поиска по уникальным значениям (например, ID).|
|Индекс с уникальными значениями (Unique Index)|Индекс, обеспечивающий уникальность значений в столбце.|Для обеспечения уникальности значений (например, email).|
|Индекс обратного списка (Bitmap Index)|Индекс с битовыми картами для колонок с малым числом уникальных значений.|Для столбцов с ограниченным числом уникальных значений, например, пол.|
|Инкрементный (Clustered Index)|Индекс, при котором данные таблицы физически упорядочены в соответствии с индексом.|Когда необходимо хранить данные в порядке индекса, например, по ID.|
|Индекс по выражению (Functional Index)|Индекс, основанный на вычисленных значениях или функциях над столбцами.|Для запросов, использующих функции или выражения в фильтрах.|
|Индекс на основе дерева (GiST — Generalized Search Tree)|Общий тип дерева, используемый для индексации сложных типов данных.|Для индексации географических данных или других сложных типов.|
|Индекс на основе префикса (Prefix Index)|Индекс, созданный на части строки, например, на первых символах.|Для текстовых полей, где важно индексировать только часть строки (например, первые несколько символов).|

---
***Почему когда много индексов, это плохо?***

|Проблема|Описание|
|---|---|
|Увеличение времени записи|При вставке, обновлении или удалении данных индексы нужно обновлять, что замедляет операции записи.|
|Большое использование места|Индексы занимают дополнительное место на диске, особенно при большом объеме данных.|
|Сложности с выбором оптимального индекса|СУБД может не выбрать лучший индекс для запроса, если их слишком много.|
|Снижение производительности запросов|Большое количество индексов может привести к дополнительным вычислениям при планировании запроса, что замедляет выполнение.|
|Усложнение управления|Управление большим количеством индексов становится сложным, включая их отслеживание и обслуживание.|
|Избыточность индексов|Некоторые индексы могут быть избыточными, что не только не ускоряет запросы, но и увеличивает нагрузку на систему.|
|Сложности с обслуживанием|Большое количество индексов усложняет операции обслуживания, такие как реорганизация и восстановление.|

---
***Что содержится внутри дерева?***

{{< figure src="B-Tree structure.png" >}}

---
***В индексе ссылка на данные или в самом индексе кешируем данные?***

В индексе хранятся **ссылки** на реальные данные, которые находятся в таблице базы данных. Эти ссылки могут быть представлены в виде:

- **Указателей на строки** в таблице, где хранятся данные.
- **Идентификаторов записей**, которые позволяют найти данные в таблице.

Например, в **B+-дереве**:

- В листьях дерева хранятся не сами данные, а **ссылки на данные** в таблице (или другие индексы).
- Внутренние узлы дерева содержат только **ключи** для направления поиска.

---
***Какие индексы по умолчанию в разных СУБД?***

---
#### 7. Нормализация и денормализация. Перечислите формы
*Нормализация* - процесс преобразования отношений базы данных к виду без избыточной информации. Избыточность - это ситуация, когда одни и те же данные хранятся в базе в нескольких местах. Нормализация проходит через несколько форм:

- **1NF** (1ая нормальная форма). Одна ячейка - одно значение
- **2NF** (2ая нормальная форма). Все не ключевые зависят от ключа
- **3NF** (3ья нормальная форма). Все не ключевые не зависят друг от друга

*Денормализация* - процесс обратный нормализации. Обычно это необходимо для повышения производительности и скорости извлечения данных, за счет увеличения избыточности данных. Производительность увеличивается за счет уменьшения сложности запросов

---
#### 8. Что такое внешний ключ?
Ключ, который должен совпадать с ключом другой таблицы

---
#### 9. Чем WHERE отличается от HAVING?
`WHERE` применяется до выполнения агрегатных функций, а `HAVING` - после

---
#### 10. Чем отличается MySQL от PostgreSQL?
**MySQL** — проще, быстрее в базовых операциях, хорош для приложений с высокой нагрузкой на чтение
    
**PostgreSQL** — мощнее, с расширенными функциями и более строгим соблюдением стандартов, лучше подходит для сложных приложений

---
#### 11. Оптимизация запросов. Какие инструменты?
- **EXPLAIN** – Показывает план выполнения запроса, что позволяет увидеть, как СУБД планирует извлекать данные.
- **EXPLAIN ANALYZE** – Выполняет запрос и показывает реальный план выполнения, включая затраченные ресурсы (время, память).
- **Indexes** – Индексы ускоряют доступ к данным, особенно при использовании в условиях WHERE.
- **pg_stat_statements** (для PostgreSQL) – Модуль для сбора статистики выполнения запросов.

---
***SQL-запрос у тебя в норме, но выполнение всё равно долгое. Твои действия?***

- **Использование индексов** – Проверь, правильно ли используются индексы. Возможно, стоит создать или пересмотреть их.
- **Оптимизация плана выполнения** – Используй EXPLAIN и EXPLAIN ANALYZE для анализа плана выполнения запроса и поиска проблемных мест.
- **Рефакторинг запроса** – Перепиши запрос, если есть более эффективный способ получить те же данные. Например, объединение нескольких подзапросов или использование более простых JOIN.
- **Проверка ресурсных ограничений** – Возможно, проблема не в запросе, а в нехватке ресурсов (CPU, память, диск).

---
***EXPLAIN. Что показывает?***

*EXPLAIN* показывает план выполнения запроса до его фактического выполнения. Он выводит, как СУБД собирается получить данные. Это включает:

- Какой тип сканирования будет применяться (Seq Scan, Index Scan).
- Сортировки и объединения (Nested Loop, Hash Join).
- Предполагаемое количество строк и стоимость выполнения на каждом этапе.

---
***Sequence Scan - что означает?***

**Sequence Scan** (Последовательное сканирование) — это метод доступа к данным в PostgreSQL и других СУБД, при котором сканируются все строки таблицы. Это самый простой и "прямолинейный" способ поиска данных, но он может быть менее эффективным для больших таблиц.

- Используется, если:
    - Нет индекса, подходящего для выполнения запроса.
    - Запрос возвращает большинство строк таблицы (эффективность индекса становится ниже).
    - Оценка стоимости (cost) последовательного сканирования ниже, чем у индексного сканирования.

```sql
EXPLAIN ANALYZE SELECT * FROM employees WHERE salary > 100000;

```

Если нет индекса по колонке `salary`, PostgreSQL выполнит последовательное сканирование.

---
***Explain analyze. Как устроен? На что обращать внимание?***

*EXPLAIN ANALYZE* не только показывает план выполнения, но и выполняет запрос, выводя фактическое время выполнения каждой операции. Полезные моменты:
- **Фактическое время** (Actual Time) – сколько времени заняла операция.
- **ROWS** – реальное количество строк, прошедших через каждый этап.
- **LOOPS** – количество раз, когда этот шаг был выполнен (важно для вложенных циклов).
  
---
#### 12. PostgreSQL. Какой инструмент для сбора статистики?
В PostgreSQL используется встроенный модуль pg_stat_statements для сбора статистики по запросам. Он сохраняет информацию о том, как часто выполняются запросы, какое время они занимают, и сколько ресурсов потребляют.

---
#### 13. PostgreSQL. Какими свойствами обладает из CAP-теоремы?

---
#### 14. Что такое селективность?
*Селективность* – это доля строк, которые будут отобраны запросом из таблицы. Чем меньше строк будет отобрано (меньше доля от общего количества строк), тем более селективен запрос. Высокая селективность обычно означает, что запрос более эффективен, так как обрабатывается меньше данных.

---
#### 15. Ключевое слово LATERAL

`LATERAL` позволяет использовать данные из каждой строки внешней таблицы в подзапросе (аналог "для каждой строки").

**Пример:**  
Допустим, у нас есть таблица `users` и мы хотим для каждого пользователя взять его последние 3 транзакции из таблицы `transactions`

```sql
SELECT u.id, u.name, t.*
FROM users u,
LATERAL (
  SELECT * 
  FROM transactions t 
  WHERE t.user_id = u.id 
  ORDER BY t.date DESC 
  LIMIT 3
) t;

```

- Для каждой строки таблицы `users` выполняется подзапрос с ограничением (`LIMIT 3`).
- Без `LATERAL` подзапрос не мог бы ссылаться на внешнюю таблицу `u`.

---
#### 16. Оконные функции. PARTITION BY	

Оконные функции выполняют вычисления над строками, разделёнными на группы (партитивные окна) или на весь набор данных.

#### `PARTITION BY`

Определяет, как данные будут разбиваться на группы. Аналог `GROUP BY`, но не агрегирует строки, а позволяет работать с ними индивидуально в пределах группы.

**Пример:**  
Пусть есть таблица `sales` с колонками `region`, `salesperson` и `sales`. Мы хотим вычислить сумму продаж в каждом регионе и ранжировать сотрудников внутри регионов.

```sql
SELECT 
  region, 
  salesperson, 
  sales, 
  SUM(sales) OVER (PARTITION BY region) AS total_region_sales, 
  RANK() OVER (PARTITION BY region ORDER BY sales DESC) AS rank_in_region
FROM sales;

```

- `PARTITION BY region`: Группировка по регионам.
- `SUM(sales)` выполняется для каждой строки, но только в рамках региона.
- `RANK()` присваивает ранг на основе продаж внутри каждого региона.

---
#### 17. cube, rollup, groupBy

Используются для создания многомерных группировок в SQL.

{{< figure src="Analityc grouping.png" >}}


 **CUBE**

Создаёт все возможные комбинации группировок.

```sql
SELECT region, product, SUM(sales)
FROM sales
GROUP BY CUBE(region, product);

```
Результат:

- Группировка по `region, product`.
- Группировка только по `region`.
- Группировка только по `product`.
- Общая сумма по всем продажам.

 **ROLLUP**

Создаёт иерархические уровни группировки (сверху вниз).

```sql
SELECT region, product, SUM(sales)
FROM sales
GROUP BY ROLLUP(region, product);

```

Результат:

- Группировка по `region, product`.
- Группировка только по `region`.
- Общая сумма по всем продажам.

 **GROUPING SETS**

Явно указывает на комбинации группировки.

```sql
SELECT region, product, SUM(sales)
FROM sales
GROUP BY GROUPING SETS ((region, product), (region), ());

```

Результат идентичен `ROLLUP`, но группы можно задать произвольно.

 **GROUP BY**

**`GROUP BY`** используется для группировки строк по определённым столбцам и применения агрегатных функций к каждой группе. Это позволяет выполнять расчёты по группам данных, например, подсчёт суммы, среднего значения и т.д.

**Пример:**  
Есть таблица `sales` с колонками `region` и `revenue`. Чтобы найти суммарный доход по каждому региону:

```sql
SELECT region, SUM(revenue) AS total_revenue
FROM sales
GROUP BY region;

```

- `region` — группирующий столбец.
- `SUM(revenue)` вычисляется для каждой группы.

Если не использовать `GROUP BY`, SQL будет рассматривать все строки как одну группу.

---
#### 18. Хранимые процедуры	

**Хранимая процедура** — это заранее сохранённый набор SQL-команд, выполняющий определённую задачу. Они позволяют повторно использовать код, обрабатывать бизнес-логику и повышать производительность.

**Ключевые особенности:**

- **Входные параметры**: передача данных в процедуру.
- **Выходные параметры**: возврат результата.
- **Логика управления потоком**: циклы, условные конструкции (`IF`, `WHILE`).

**Пример создания и вызова хранимой процедуры:**

```sql
CREATE PROCEDURE CalculateBonus (IN employee_id INT, OUT bonus_amount DECIMAL(10,2))
BEGIN
  SELECT salary * 0.1 INTO bonus_amount
  FROM employees
  WHERE id = employee_id;
END;

```

Вызов:
```sql
CALL CalculateBonus(101, @bonus);
SELECT @bonus;

```

Преимущества:

- Снижение трафика между клиентом и сервером.
- Лучшая организация кода.

---
#### 19. Как работает Serializable?	

`Serializable` — это самый строгий уровень изоляции транзакций в базах данных.  
Он обеспечивает, что транзакции выполняются так, будто они происходят последовательно (по одной за раз), даже если фактически выполняются параллельно.

**Особенности:**

- Полностью предотвращает:
    - **Повторное чтение**: изменение данных между повторными чтениями.
    - **Фантомное чтение**: появление новых строк, которые соответствуют запросу.
    - **Грязное чтение**: чтение данных, которые не были зафиксированы.

**Механизм работы:**

- Использует блокировки или механизм версионирования (MVCC) для управления конкурентным доступом.
- Может приводить к снижению производительности из-за увеличения времени ожидания между транзакциями.

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

BEGIN TRANSACTION;

-- Первая транзакция
SELECT SUM(balance) FROM accounts WHERE account_type = 'savings';

-- Вторая транзакция (ожидание завершения первой)
INSERT INTO accounts (account_type, balance) VALUES ('savings', 500);

COMMIT;

```

---
#### 20. View, materialized view. представлениями, материализованными представлениями?

 **View (Представление):**

- Логический слой над таблицами, который хранит SQL-запрос.
- **Данные не хранятся физически**, каждый раз при обращении к представлению выполняется связанный с ним запрос.
- Используется для упрощения работы с данными, ограничения доступа и повторного использования сложных запросов.

```sql
CREATE VIEW ActiveUsers AS
SELECT id, name, email
FROM users
WHERE status = 'active';

-- Использование представления
SELECT * FROM ActiveUsers;

```

 **Materialized View (Материализованное представление):**

- Сохраняет результат SQL-запроса физически (в отличие от обычного представления).
- Улучшает производительность сложных запросов, так как данные не пересчитываются каждый раз.
- Требует обновления (`REFRESH`), чтобы быть синхронизированным с исходными таблицами.

```sql
CREATE MATERIALIZED VIEW SalesSummary AS
SELECT region, SUM(revenue) AS total_revenue
FROM sales
GROUP BY region;

-- Обновление данных
REFRESH MATERIALIZED VIEW SalesSummary;

```

Сравнение:

| Параметр       | View                       | Materialized View        |
| ------------------ | ------------------------------ | ---------------------------- |
| Хранение данных    | Нет                            | Да                           |
| Обновление         | Автоматическое                 | Требует явного обновления    |
| Производительность | Медленнее для сложных запросов | Быстрее для сложных запросов |


---	
#### 21. C помощью SQL блокировка строки? - SELECT FOR UPDATE	

**`SELECT FOR UPDATE`** используется для блокировки строк в таблице, чтобы предотвратить их изменение другими транзакциями до тех пор, пока текущая транзакция не завершится (через `COMMIT` или `ROLLBACK`).


```sql
BEGIN;

-- Блокировка строки с id = 1
SELECT * FROM accounts
WHERE id = 1
FOR UPDATE;

-- Делаем обновление
UPDATE accounts
SET balance = balance - 100
WHERE id = 1;

COMMIT;

```

- В данном случае, строка с `id = 1` заблокирована для других транзакций, пока текущая не завершится.
- Если другая транзакция попытается заблокировать ту же строку, она будет ожидать завершения текущей транзакции.

---
#### 22. UNION vs UNION ALL	

`UNION` и `UNION ALL` оба объединяют результаты двух или более запросов, но есть ключевые отличия.

|Критерий|UNION|UNION ALL|
|---|---|---|
|Удаление дубликатов|Удаляет дубликаты.|Не удаляет дубликаты.|
|Производительность|Медленнее из-за проверки дубликатов.|Быстрее, так как не удаляет дубли.|
|Использование памяти|Может занимать больше памяти.|Занимает меньше памяти.|
|Тип результата|Только уникальные строки.|Все строки, включая дубликаты.|
|Пример|`SELECT * FROM A UNION SELECT * FROM B`|`SELECT * FROM A UNION ALL SELECT * FROM B`|

---
***Что делает UNION?***

1. **Объединяет результаты нескольких SELECT-запросов.**
2. Удаляет дубликаты, возвращая уникальные строки.
3. Требует, чтобы количество и типы столбцов в объединяемых запросах совпадали.

```sql
SELECT city FROM customers
UNION
SELECT city FROM suppliers;

```

Если оба запроса возвращают `city = 'New York'`, то в результате `UNION` эта строка появится только один раз. В случае `UNION ALL` — дважды.

---
#### 23  Расскажи про ключевое слово DISTINCT?	

Ключевое слово `DISTINCT` в SQL используется для выборки уникальных значений в результатах запроса. Оно устраняет дублирующиеся строки.

---
#### 24. Что такое табличные выражения?

Табличные выражения — это временные, именованные наборы данных, создаваемые в рамках запроса. Они помогают структурировать запросы, делая их более читаемыми. Основные виды:
1. **CTE (Common Table Expressions)** — объявляются с помощью ключевого слова `WITH`

```sql
WITH recent_sales AS (
    SELECT * FROM sales WHERE sale_date > '2023-01-01'
)
SELECT * FROM recent_sales WHERE amount > 1000;

```

Временная таблица `recent_sales` доступна только внутри текущего запроса.

2. **Подзапросы (Subqueries)**

```sql
SELECT name 
FROM employees
WHERE department_id IN (
    SELECT id FROM departments WHERE location = 'New York'
);

```

---
#### 25. Для чего используется Database Connection Pool? (Hikari) Переполнение connection pool	

**Database Connection Pool** — это пул соединений с базой данных, который управляет ограниченным числом соединений, чтобы уменьшить нагрузку на сервер базы данных и повысить производительность. Hikari — один из самых популярных Connection Pool.

**Почему нужен пул?**

- Уменьшает накладные расходы на создание/закрытие соединений.
- Повышает производительность многопоточных приложений.

**Переполнение Connection Pool**: Происходит, когда приложению требуется больше соединений, чем разрешено пулом. Возможные причины:

- Утечка соединений (не закрываются после использования).
- Неправильная настройка `maxPoolSize`.
- Избыточная нагрузка на приложение.

Решения:

1. Закрывайте соединения через `try-with-resources`
2. Увеличьте `maxPoolSize`, если это оправдано.

---
#### 26. Блокировки и локи. Оптимистичная и Пессимистичная
Блокировки (или локи) в базе данных — это механизм, который помогает управлять параллельным доступом к одним и тем же данным, чтобы избежать ошибок и конфликтов. Есть два типа блокировок:
- **Оптимистическая блокировка**. При сохранении данных проверяется, не изменились ли они с момента их чтения. Если изменились — происходит ошибка, и нужно повторить транзакцию.
- **Пессимистическая блокировка**. Означает, что данные блокируются сразу, чтобы другие транзакции не могли их изменить, пока текущая транзакция не завершится.

**Оптимистичная блокировка**:

- Используется, когда конфликты редки.
- Проверяется, изменились ли данные с момента их чтения.
```sql
SELECT version FROM orders WHERE id = 1;
-- Обновляем, если версия не изменилась
UPDATE orders 
SET status = 'processed', version = version + 1
WHERE id = 1 AND version = 5;

```

**Пессимистичная блокировка**:

Блокирует данные, чтобы другие транзакции не могли их изменить.

```sql
SELECT * FROM orders WHERE id = 1 FOR UPDATE;

```

 Сравнение

|Характеристика|Оптимистичные локи|Пессимистичные локи|
|---|---|---|
|Конфликты|Редкие|Частые|
|Механизм|Проверка версии данных|Блокировка ресурса|
|Производительность|Выше при редких конфликтах|Ниже из-за блокировок|
|Обработка конфликтов|Требует доп. кода|Не требуется|
|Применимость|Чтение превалирует над записью|Высококонкурентная запись|

---
#### 27. БД. Constraint. Какие существуют?	

**Constraint (ограничение)** — это правило, накладываемое на столбцы или таблицы, чтобы обеспечить целостность и корректность данных.

| Ограничение        | Описание                                       | Применимость                    |
| ------------------ | ---------------------------------------------- | ------------------------------- |
| **NOT NULL**       | Поле обязательно для заполнения                | Идентификаторы, ключевые данные |
| **UNIQUE**         | Значения в поле уникальны                      | Email, username                 |
| **PRIMARY KEY**    | Уникально идентифицирует строку                | Основной идентификатор записи   |
| **FOREIGN KEY**    | Обеспечивает целостность связи между таблицами | Таблицы с зависимыми данными    |
| **CHECK**          | Устанавливает условия для значений             | Бизнес-правила                  |
| **DEFAULT**        | Значение по умолчанию                          | Даты, статусы                   |
| **AUTO_INCREMENT** | Генерация уникальных идентификаторов           | Первичные ключи                 |

---
#### 28. Primary Key

**Primary Key (PK)** — это уникальный идентификатор записи в таблице. Без него сложно эффективно работать с данными, особенно в больших таблицах.

---
***Зачем нужен PK?***

1. **Гарантия уникальности**: PK обеспечивает, что ни одна запись не будет дублироваться.
2. **Связь между таблицами**: Используется как основа для создания внешних ключей (FK).
3. **Ускорение поиска**: PK автоматически индексируется, что ускоряет выборку данных.
4. **Идентификация строк**: Позволяет уникально идентифицировать каждую запись.

---
***PK индексирован?***

Да, Primary Key **автоматически индексируется** базой данных. Это индекс:

- Ускоряет поиск, сортировку и фильтрацию по PK.
- Гарантирует уникальность значений в столбце PK.


