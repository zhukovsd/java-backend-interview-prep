+++
title = 'Web'
weight = 4
bookFlatSection = true
+++

## Web

#### 1. REST
*REST* - это архитектурный стиль взаимодействия клиент-серверного WEB-приложения. Клиент-сервер общаются через протокол HTTP, а формат данных - JSON

---
#### 2. RESTful и RESTless
*RESTful* строго следует принципам REST, используя стандартные методы HTTP и четко структурированные URL, а *RESTless* нарушает эти принципы, делая взаимодействие менее стандартным и гибким

---
#### 3. REST vs SOAP
*SOAP* и *REST* – это два разных подхода к разработке API. Подход SOAP отличается высокой степенью структурированности и использует формат данных XML. REST более гибкий и позволяет приложениям обмениваться данными в нескольких форматах.

> На данный момент SOAP устаревший подход, использующийся на легаси проектах

---
#### 4. В каких ситуациях допустимо использование RESTless
Использование RESTless допустимо:
- В небольшом приложение, где строгие принципы REST не критичны
- Если существующая система уже использует другой подход и переделка будет слишком сложной

---
#### 5. REST vs RPC. Как выбрать что лучше подходит?
Для работы с данными это обычно всегда *REST*

Для работы с действиями, операциями(logout,login,signin) *RPC* будет смотреться лучше

*RPC* - все описывает глаголами, а *REST* - существительными

---
#### 6. Назовите 6 принципов REST API
- **Клиент-серверная архитектура**: Клиент и сервер работают независимо друг от друга. Клиент отправляет запросы на сервер, сервер их принимает и возвращает ответы. Это позволяет развиваться клиенту и серверу независимо друг от друга
- **Stateless (Отсутствие состояния)**: Сервер не сохраняет информацию о состоянии клиента между запросами. Информация о текущей сессии должна целиком храниться у клиента
- **Кеширование**: В REST API сервер может запомнить результаты частых запросов, чтобы быстрее их вернуть и не тратить ресурсы на повторные вычисления.
- **Единообразие интерфейса**: В API используются стандартные команды (GET, POST, PUT, DELETE), чтобы взаимодействие было простым и предсказуемым
- **Слои**: Система может быть разделена на несколько слоев, каждый из которых выполняет свою задачу
- **Код по требованию**: Иногда сервер может отправлять клиенту код (например, скрипты), который клиент может использовать для выполнения задач

---
#### 7. Идемпотентный метод
Это метод, который сколько раз ты не выполнишь принесёт один результат, не изменяющий состояние сервера
Идемпотентными считаются:

- GET
- PUT
- DELETE

Не идемпотентными считаются:

- POST
- PATCH

---
#### 8. Основные HTTP методы
- GET. Получение ресурса.
- POST. Создание нового ресурса.
- PUT. Полное обновление ресурса или создание, если его нет.
- PATCH. Частичное обновление ресурса.
- DELETE. Удаление ресурса.
- HEAD. Получение заголовка ресурса
- OPTIONS. Узнать доступные методы для ресурса

---
#### 9. Статусы ответов
- 100-199. Информационные
- 200-299. Успешные
- 300-399. Перенаправления
- 400-499. Клиентские ошибки
- 500-599. Серверные ошибки

---
#### 10. GET vs POST

|**Критерий**|**GET**|**POST**|
|---|---|---|
|**Назначение**|Получение данных.|Создание или изменение данных.|
|**Передача данных**|Данные передаются в URL (в строке запроса).|Данные передаются в теле (body) HTTP-запроса.|
|**Безопасность**|Менее безопасный (данные видны в URL и логах сервера).|Более безопасный (данные не видны в URL).|
|**Идёмпотентность**|Идёмпотентен (повторный запрос не изменяет состояние).|Не идёмпотентен (повторный запрос может создать дубликат).|
|**Кэширование**|Поддерживается браузерами и прокси-серверами.|Не поддерживается кэширование по умолчанию.|
|**Ограничение на длину**|Ограничения на длину строки URL зависят от браузера.|Ограничения на длину тела запроса обычно отсутствуют.|
|**Пример использования**|Поиск данных, отображение страниц.|Отправка форм, создание ресурсов, изменение данных.|

---
***Почему для конфиденциальных данных рекомендуется использовать POST, а не GET запросы***

1. **Безопасность**:

- В GET запросе данные передаются в URL, который может быть виден в истории браузера, логах сервера и прокси.
- В POST данные передаются в теле запроса, что снижает риск случайной утечки.
  
2. **Ограничения длины**:

- Длина URL в GET ограничена браузерами или серверами, поэтому большие объемы данных (например, конфиденциальные формы) могут не пройти.

3. **Кэширование**:

- GET запросы могут быть кэшированы прокси-серверами или браузерами, что нежелательно для конфиденциальной информации.

---
***Можем ли всегда использовать только POST и не работать с GET?***

Теоретически — да, но это нарушает принципы REST и архитектуру веб-приложений:

1. **REST-принципы**:
    
    - GET предназначен для получения данных, POST — для создания. Использование POST для всех операций затрудняет понимание и поддержку API.
2. **Оптимизация и кэширование**:
    
    - GET запросы могут быть кэшированы, что ускоряет работу. POST запросы не кэшируются по умолчанию.
3. **Поисковые системы и SEO**:
    
    - GET используется для индексации страниц. Если использовать только POST, страницы не попадут в поисковую выдачу.
  
---
***Можем ли с помощью GET создать ресурс? Есть ли технические ограничения?***

1. **Технические ограничения**:
    
    - С точки зрения HTTP-протокола, GET не должен создавать ресурсы. Но технически сервер может обрабатывать GET запросы так, чтобы они изменяли данные (например, создавали ресурс).
  
2. **Практика**:
    
    - Создание или изменение ресурсов через GET нарушает идёмпотентность и может вызвать проблемы с кэшированием и повторными запросами.

3. **Рекомендация**:
    
    - Для создания ресурсов всегда следует использовать POST, чтобы соблюсти семантику HTTP и избежать неожиданных ошибок

---
***Почему решили из метода GET убрать body?***

1. **Неопределённое поведение**:
    
    - Семантика GET подразумевает только получение данных. Тело запроса не является обязательной частью этой семантики, поэтому серверы могут игнорировать его.

2. **Совместимость**:
    
    - Многие прокси-серверы, фреймворки и библиотеки не поддерживают body в GET, что могло бы привести к проблемам совместимости.

3. **Простота и идёмпотентность**:
    
    - GET запросы считаются идёмпотентными и безопасными. Наличие тела могло бы изменить эту концепцию, создавая больше путаницы.

4. **Архитектурное решение**:
    
    - Для сложных запросов с данными в теле рекомендуется использовать POST, а для простых запросов — GET. Это упрощает архитектуру и делает API предсказуемым.

---
#### 11. Разница HTTP и HTTPs
При использовании HTTPs - данные, передаваемые серверу - зашифрованы

---
#### 12. Из чего состоит HTTP запрос

|**Часть**|**Описание**|
|---|---|
|**Стартовая строка (Request Line)**|Содержит метод запроса, URL-адрес и версию протокола HTTP. Например: `GET /index.html HTTP/1.1`.|
|**Заголовки (Headers)**|Метаданные о запросе: тип содержимого, длина, информация об авторизации и многое другое. Пример: `Content-Type: application/json`.|
|**Пустая строка**|Разделяет заголовки и тело запроса.|
|**Тело запроса (Body)**|Непосредственно данные, которые передаются серверу (например, JSON, XML, файл). Присутствует не всегда.|

---
#### 13. Какие методы авторизации существуют для HTTP протокола?

|Метод|Описание|Особенности|
|---|---|---|
|**Basic Authentication**|Клиент отправляет логин и пароль, закодированные в Base64, в заголовке `Authorization: Basic <encoded_credentials>`.|Уязвим для перехвата без использования HTTPS. Рекомендуется использовать в сочетании с SSL/TLS.|
|**Bearer Token**|Клиент отправляет токен в заголовке `Authorization: Bearer <token>`.|Используется с OAuth2 и JWT. Удобен для работы с API.|
|**Digest Authentication**|Сервер отправляет клиенту nonce (одноразовый токен), который клиент использует для хеширования своих учетных данных.|Устаревший метод, сложен в реализации, менее популярен.|
|**OAuth 2.0**|Механизм авторизации через сторонние сервисы. Клиент получает токен доступа от сервера авторизации.|Расширяемый, позволяет использовать сторонние приложения (например, Google, Facebook).|
|**API Key**|Клиент отправляет ключ API в заголовке, URL или параметре запроса.|Прост, но менее безопасен. Требует защищенной передачи (HTTPS).|
|**Session-based**|Клиент сохраняет идентификатор сессии в cookie, а сервер проверяет сессию по базе данных.|Широко используется в веб-приложениях, требует управления серверной сессией.|
|**Custom Authentication**|Использование кастомных токенов или механизмов авторизации.|Гибкость, но требует больше усилий для реализации и обеспечения безопасности.|
|**Mutual TLS**|Двусторонняя аутентификация с использованием сертификатов TLS.|Высокий уровень безопасности, сложен в настройке.|


---
#### 14. Из чего состоит JSON Web Token?


JWT — это стандартный способ передачи информации в компактном формате (JSON), подписанного для обеспечения его целостности и подлинности. Используется для авторизации, передачи данных между клиентом и сервером.

 **Из чего состоит JWT?**

JWT состоит из трех частей, разделенных точками (`.`):

```
<Header>.<Payload>.<Signature>
```

1. **Header (Заголовок):**
    
    - Содержит метаинформацию о токене:
        - Алгоритм подписи (например, HMAC SHA256, RSA).
        - Тип токена (`JWT`).
    - Пример:
        
        ```json
        {
          "alg": "HS256",
          "typ": "JWT"
        }
        ```
        
2. **Payload (Полезная нагрузка):**
    
    - Содержит данные (клеймы), которые нужно передать.
    - Может включать:
        - **Зарезервированные клеймы:** стандартные поля, такие как `iss` (издатель), `exp` (время истечения), `sub` (тема).
        - **Пользовательские клеймы:** любые данные, такие как роль пользователя, идентификатор и т.д.
    - Пример:
        
        ```json
        {
          "sub": "1234567890",
          "name": "John Doe",
          "admin": true
        }
        ```
        
3. **Signature (Подпись):**
    
    - Подписывает токен, чтобы проверить его подлинность.
    - Формируется с использованием заголовка, полезной нагрузки и секретного ключа (или приватного ключа в случае асимметричного шифрования).
    - Пример формулы:
        
        ```
        HMACSHA256(
          base64UrlEncode(header) + "." + base64UrlEncode(payload),
          secret
        )
        ```

 **Пример JWT:**

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

1. **Header (Base64 URL):**
    
    ```
    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
    ```
    
2. **Payload (Base64 URL):**
    
    ```
    eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9
    ```
    
3. **Signature:**
    
    ```
    SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
      ```


