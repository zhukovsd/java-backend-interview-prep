[category]
  id = 21
  title = "Деплой"
  popularity = 10.31

[[questions]]
  id = 1
  question = "CI/CD"
  answer = "*CI/CD* (Continuous Integration / Continuous Delivery) — это набор практик и инструментов для автоматизации интеграции кода и доставки приложений:\n\n- *CI (Continuous Integration)*: Автоматическое тестирование и интеграция кода в общую ветку. После каждого коммита запускаются тесты, сборка.\n- *CD (Continuous Delivery)*: Автоматизация процесса доставки приложений на различные среды (dev, staging, production) после успешного тестирования.\n\n"
  popularity = 2.67

[[questions]]
  id = 2
  question = "Как работает Docker. Из чего состоит докер образ?"
  answer = "Docker-образ состоит из:\n\n- *Базового слоя* (например, alpine, ubuntu).\n- *Набора слоёв файловой системы*, которые включают установленные пакеты, зависимости и конфигурации.\n- *Манифеста* (метаданных) образа, описывающих его слои и зависимости.\n\n"
  popularity = 3.44

[[questions]]
  id = 3
  question = "Что такое слой? Как мы можем создать новый слой?"
  answer = "*Слой* — это промежуточный этап, создаваемый при выполнении каждой команды в Dockerfile (`RUN`, `COPY`, `ADD`). Каждый слой является неизменяемым, а Docker использует кэш для уже созданных слоёв.\n\n- Новый слой создается при выполнении команды в Dockerfile. Например, каждая команда `RUN apt-get install ...` добавляет новый слой.\n\n"
  popularity = 0.38

[[questions]]
  id = 4
  question = "Docker compose"
  answer = "*Docker Compose* — это инструмент для запуска и управления несколькими Docker-контейнерами, описанными в одном файле `docker-compose.yml`. Он позволяет легко управлять зависимыми сервисами (например, веб-сервер, база данных) в одном окружении.\n\n---\n***Разница между Docker File и Docker Compose***\n\n**Dockerfile** и **Docker Compose** — это инструменты Docker, но они служат для разных задач:\n\n1. **Dockerfile**\n    \n    - Это файл, где вы описываете, как собрать образ (шаблон) контейнера.\n    - С его помощью можно указать, какие программы устанавливать, какие файлы добавлять и какую команду запускать при старте контейнера.\n    - Применяется для создания **одного образа**.\n    - *Пример*:  \n        Вы хотите запустить приложение на Java. В Dockerfile вы указываете, чтобы скачивалась нужная версия JDK, копировался ваш код и запускалось приложение.\n2. **Docker Compose**\n    \n    - Это инструмент для управления несколькими контейнерами. Он не создает образы, а работает с уже готовыми.\n    - В файле `docker-compose.yml` вы описываете, как разные контейнеры будут взаимодействовать: какие порты открыть, какие сети использовать, какие данные хранить.\n    - Применяется для **оркестрации нескольких сервисов**.\n    - *Пример*:  \n        Ваше приложение на Java использует базу данных. В Compose вы описываете, чтобы одновременно запускались контейнеры с приложением и с базой данных, а также настраиваете их соединение.\n\n**Ключевая разница:**\n\n- **Dockerfile** нужен для создания образа одного контейнера.\n- **Docker Compose** — для управления и запуска нескольких связанных контейнеров.\n\n"
  popularity = 3.05

[[questions]]
  id = 5
  question = "ARG, ENV. В чем отличия?"
  answer = "- *ARG*: Параметры, которые передаются во время сборки образа. Доступны только во время создания Docker-образа и не сохраняются в контейнере.\n- *ENV*: Переменные окружения, которые задаются в контейнере и могут быть использованы приложениями, запущенными в контейнере.\n\n"
  popularity = 0.38

[[questions]]
  id = 6
  question = "Docker cmd vs entrypoint"
  answer = "- *CMD*: Определяет команду по умолчанию, которая выполняется при запуске контейнера. Может быть переопределена при запуске.\n- *ENTRYPOINT*: Указывает фиксированную команду, которая всегда будет выполняться. Аргументы могут быть переданы через `CMD` или командную строку.\n\n"
  popularity = 0.76

[[questions]]
  id = 7
  question = "Отличия контейнеризации от виртулизации"
  answer = "- *Контейнеризация*: Разделение приложений на уровне операционной системы. Контейнеры используют одно ядро ОС и изолируются друг от друга.\n- *Виртуализация*: Полная эмуляция аппаратного обеспечения. Каждый виртуальный сервер работает на собственной копии операционной системы.\n\n"
  popularity = 4.96

[[questions]]
  id = 8
  question = "Поддержка сервиса в продакшене, мониторинг его работы. Общие подходы?"
  answer = "Поддержка сервиса в продакшене включает в себя обеспечение его доступности, производительности и надежности.\n\n **Общие подходы:**\n\n1. **Мониторинг и логирование:**\n    \n    - Используйте инструменты мониторинга:\n        - **Prometheus**: Сбор метрик.\n        - **Grafana**: Визуализация метрик.\n        - **ELK Stack (Elasticsearch, Logstash, Kibana)**: Анализ и хранение логов.\n        - **Datadog / New Relic**: Для полного мониторинга приложения и инфраструктуры.\n    - Настройте логирование:\n        - Сохраняйте логи в централизованной системе.\n        - Подключите алерты на аномалии (ошибки, снижение производительности).\n2. **Анализ производительности:**\n    \n    - Используйте **APM-инструменты** (Application Performance Monitoring):\n        - Определение медленных запросов или узких мест.\n    - Анализируйте **метрики CPU, памяти, I/O, использования сети**.\n3. **Управление отказами:**\n    \n    - Настройте систему алертов (например, через **PagerDuty**).\n    - Автоматизируйте перезапуск сервисов с помощью **Docker Restart Policies** или **Kubernetes Deployment Strategies**.\n4. **Планы восстановления:**\n    \n    - Настройте резервное копирование (базы данных, конфигураций).\n    - Разработайте сценарии восстановления после сбоев.\n5. **Масштабируемость:**\n    \n    - Горизонтальное масштабирование с помощью **Kubernetes**, **Docker Swarm** или облачных решений (AWS ECS, Azure AKS, Google GKE).\n    - Используйте **автоскейлинг** для добавления ресурсов в моменты пиковых нагрузок.\n6. **Интеграция CI/CD:**\n    \n    - Автоматическое развертывание обновлений с предварительным тестированием.\n    - Настройка этапов отката (rollback) в случае неудачи.\n7. **Health Checks:**\n    \n    - Настройте проверки работоспособности сервиса (например, HTTP `/health` endpoint).\n    - Используйте встроенные механизмы Docker или Kubernetes для мониторинга контейнеров.\n\n **Пример мониторинга сервиса**\n\n1. **Мониторинг метрик:**\n    \n    - Настройка **Prometheus** для сбора данных о запросах, загрузке CPU и использовании памяти.\n    - Визуализация дашбордов в **Grafana**.\n2. **Логирование:**\n    \n    - Логи сервисов собираются через **Fluentd** или **Filebeat** и передаются в **Elasticsearch**.\n3. **Алерты:**\n    \n    - Настройка оповещений через **Slack** или **PagerDuty** для уведомлений при отказах или аномалиях.\n4. **Проверки здоровья:**\n    \n    - Добавление `/health` endpoint, возвращающего статус 200, если сервис работает корректно."
  popularity = 0.38
