[section]
  id = 12
  title = "NoSQL"
  popularity = 3.82

[[items]]
  id = 1
  question = "NoSQL типы БД"
  answer = "| Тип                     | Пример      | Особенности                  | Когда использовать                     |\n| --------------------------- | --------------- | -------------------------------- | ------------------------------------------ |\n| **Документные**             | MongoDB         | JSON-документы, гибкая структура | Динамические, неструктурированные данные   |\n| **Ключ-значение**           | Redis, DynamoDB | Максимально быстрый доступ       | Кэш, данные с уникальными ключами          |\n| **Колонко-ориентированные** | Cassandra       | Хранение по колонкам             | Аналитика, обработка больших данных        |\n| **Графовые**                | Neo4j           | Узлы и связи                     | Моделирование сложных связей между данными |\n\n"
  popularity = 1.15

[[items]]
  id = 2
  question = "Для чего используется Redis?"
  answer = "**Redis** — это высокопроизводительная NoSQL база данных, которая работает в оперативной памяти (in-memory), обеспечивая минимальные задержки. Основное назначение Redis — хранение данных в виде ключ-значение.\n\n"
  popularity = 3.05

[[items]]
  id = 3
  question = "Что такое Кэш?"
  answer = "**Кэш** — это временное хранилище данных, созданное для ускорения повторного доступа к ним.\n\n **Преимущества**:\n\n- **Ускорение**: Данные быстрее извлекаются из кэша, чем из основного хранилища.\n- **Экономия ресурсов**: Уменьшение нагрузки на сервер базы данных.\n- **Снижение задержек**: Быстрый доступ к часто используемым данным.\n\n **Пример**:\n\n- Кэширование результата SQL-запроса:\n    1. Пользователь делает запрос к базе данных.\n    2. Результат сохраняется в Redis.\n    3. Повторный запрос возвращает данные из кэша Redis.\n\n---\n***Подходы к настройке инвалидации кэша***\n\nИнвалидация кэша необходима для обеспечения актуальности данных в кэше. Существует несколько основных подходов:\n\n 1. **Time-to-Live (TTL)**\n\n- **Описание**: Устанавливается время жизни данных в кэше. После истечения этого времени данные удаляются автоматически.\n- **Преимущества**: Простота настройки, минимальная нагрузка на систему.\n- **Недостатки**: Возможна работа с устаревшими данными до истечения TTL.\n- **Пример**:\n    \n    ```java\n    redis.set(key, value, 60); // Удаление через 60 секунд\n    ```\n    \n\n---\n\n 2. **Manual Invalidation**\n\n- **Описание**: Инвалидация данных выполняется вручную, например, при обновлении данных в основной базе данных.\n- **Преимущества**: Полный контроль над процессом.\n- **Недостатки**: Возможен человеческий фактор — забыть удалить данные из кэша.\n- **Пример**: Удаление ключа после изменения записи в базе.\n    \n    ```java\n    redis.del(\"user:123\");\n    ```\n    \n\n---\n\n 3. **Write-Through**\n\n- **Описание**: Данные сначала записываются в кэш, а затем в основное хранилище.\n- **Преимущества**: Актуальность данных в кэше всегда гарантирована.\n- **Недостатки**: Запись медленнее из-за двойной операции (кэш + база).\n- **Пример**: Обновление данных пользователя.\n    \n    ```java\n    redis.set(\"user:123\", updatedData);\n    database.update(user);\n    ```\n    \n\n---\n\n 4. **Read-Through**\n\n- **Описание**: Если данных нет в кэше, они автоматически загружаются из базы данных и сохраняются в кэш.\n- **Преимущества**: Удобство и минимизация кэш-промахов.\n- **Недостатки**: Первая загрузка данных занимает больше времени.\n- **Пример**: Ленивое заполнение кэша.\n    \n    ```java\n    String value = redis.get(key);\n    if (value == null) {\n        value = database.query(key);\n        redis.set(key, value);\n    }\n    ```\n    \n\n---\n\n 5. **Cache-Aside**\n\n- **Описание**: Приложение сначала проверяет кэш. Если данных нет, оно загружает их из базы, обновляет кэш и возвращает данные.\n- **Преимущества**: Гибкий и широко используемый подход.\n- **Недостатки**: Требуется ручное управление данными в кэше и их синхронизация.\n- **Пример**:\n    \n    ```java\n    String value = redis.get(key);\n    if (value == null) {\n        value = database.query(key);\n        redis.set(key, value);\n    }\n    ```\n    \n\n---\n\n 6. **Event-Driven Invalidation**\n\n- **Описание**: Кэш автоматически обновляется при изменении данных в основной базе с помощью событий (например, через очередь сообщений).\n- **Преимущества**: Данные в кэше всегда актуальны.\n- **Недостатки**: Сложность реализации, необходимость обработки событий.\n- **Пример**: Отправка события при обновлении базы.\n    \n    ```java\n    eventBus.publish(\"userUpdated\", userId);\n    ```\n    \n---\n***Локальный vs распределенный кэш***\n\n| Критерий           | Локальный кэш                      | Распределенный кэш                    |\n| ---------------------- | -------------------------------------- | ----------------------------------------- |\n| **Расположение**       | В памяти одного узла (сервер/процесс). | Общий для нескольких узлов.               |\n| **Пример реализации**  | `ConcurrentHashMap`, Guava Cache.      | Redis, Memcached.                         |\n| **Производительность** | Высокая (минимальная задержка).        | Зависит от сети и задержек доступа.       |\n| **Масштабируемость**   | Ограничена памятью одного узла.        | Масштабируется для распределенных систем. |\n| **Доступность**        | Только для локального узла.            | Доступен для всех участников системы.     |\n| **Сложность**          | Прост в реализации.                    | Требует настройки и управления сетью.     |\n| **Инвалидация данных** | Уникальна для каждого узла.            | Единая для всех узлов.                    |\n| **Применение**         | Подходит для одиночных серверов.       | Идеален для микросервисов и кластеров.    |"
  popularity = 0.76
