[section]
  id = 4
  title = "Java Core"
  popularity = 68.65

[[items]]
  id = 1
  question = "Расскажи мне про контракт и свойства Equals & Hashcode"
  answer = "***Контракт:***\n\n- Если `hashCode()` двух объектов возвращает разные значения, то они не могут быть равны\n- Если `equals()` объектов true, то и хеш-коды должны быть равны\n- Переопределив `equals()`, всегда переопределять `hashCode()`\n- Если у объектов одинаковый `hashCode()`, то они не обязательно `equals()` \n- При каждом вызове `hashCode()` для одного и того же объекта должен возвращаться один и тот же хеш-код\n\n***Свойства equals():***\n Метод `equals()` реализует отношение равенства (эквивалентности), которое обладает следующими свойствами:\n  - **Рефлексивность**. Объект должен быть равен самому себе (`x.equals(x) == true`)\n  - **Симметричность**. Любые два объекта должны иметь одно и то же мнение относительно своего равенства или неравенства (`x.equals(y) == true` и `y.equals(x) == true`)\n  - **Транзитивность**. Если один объект равен второму, а второй равен третьему, то и первый объект должен быть равен третьему (`x.equals(y) == true` и `y.equals(z) == true` и `x.equals(z) == true`)\n  - **Непротиворечивость**. Если два объекта равны, они должны быть равны всегда, пока один из них (или оба они) не будет изменен\n  - Для любой ненулевой ссылки на значение `х` выражение `х.equals(null)` должно возвращать `false`.\n\n  ***Свойства hashCode():***\n  - **Согласованность**. При каждом вызове `hashCode()` для одного и того же объекта в рамках одной программы должно возвращаться одно и то же значение, если поля объекта, участвующие в расчете хеш-кода, не изменились\n  - **Равенство и хеш-код.** Если два объекта равны по методу `equals()`, их хеш-коды тоже должны быть равны. Однако обратное не обязательно — объекты с одинаковым хеш-кодом могут быть не равны\n  - **Распределение**. Реализация `hashCode()`, возвращающая разный хеш-код для неравных объектов позволяет увеличить эффективность работы с хеш-структурами данных (такими как HashMap или HashSet) за счёт распределения объектов по разным корзинам хеш-таблицы\n\n---"
  popularity = 20.24

[[items]]
  id = 2
  question = "Что такое коллизия?"
  answer = "Коллизия возникает, когда у разных объектов одинаковые хеш-коды\n\n---\n ***Что будет, если переопределить equals() не переопределяя hashCode()?***\n- Объект, который по `equals()` равен существующему ключу в HashMap, может не быть найден, если их хеш-коды различаются. Это связано с тем, что HashMap сначала использует `hashCode()` для поиска корзины, а уже потом сравнивает объекты по `equals()`.\n- При попытке удалить ключ, который равен другому ключу по `equals()`, но имеет другой `hashCode()`, удаление может не сработать.\n\n---"
  popularity = 3.97

[[items]]
  id = 3
  question = "Какие типы ссылок существуют в Java?"
  answer = "- **Сильная ссылка.** Обычная ссылка, которая повсеместно используется (`Object obj = new Object()`). Объект не будет удален сборщиком мусора, пока на него есть хотя бы одна сильная ссылка\n- **Мягкая ссылка.** Используются для кеширования. Объект, на который ссылается мягкая ссылка, будет удален сборщиком мусора только при нехватке памяти (`SoftReference<MyObject> softRef = new SoftReference<>(new MyObject())`)\n- **Слабая ссылка.** Объект, на который ссылается слабая ссылка, может быть удален сборщиком мусора при следующей проверке, даже если на него есть слабые ссылки (`WeakReference<MyObject> weakRef = new WeakReference<>(new MyObject())`)\n- **Фантомная ссылка**. Используется для отслеживания, когда объект был удален из памяти. Фантомная ссылка не позволяет получить доступ к объекту напрямую, она только сигнализирует, что объект скоро будет удален (`PhantomReference<MyObject> phantomRef = new PhantomReference<>(new MyObject(), referenceQueue)`)\n\n---"
  popularity = 3.97

[[items]]
  id = 4
  question = "Какой класс называют Immutable?"
  answer = "Иммутабельный класс - класс, экземпляры которого не могут быть изменены после создания. Принципы создания:\n  - Поля private `final`  \n  - Не предоставляйте методы, которые изменяют состояние объекта (никаких setter-ов)\n  - Гарантируйте невозможность расширения класса (класс делаем `final`)\n  - Все поля устанавливаются через конструктор\n  - Обеспечьте монопольный доступ ко всем изменяемым компонентам. Если класс имеет любые поля, ссылающиеся на изменяемые объекты, убедитесь, что клиенты класса не смогут получить ссылки на эти объекты (защитные копии `(defensive copies)`, использование иммутабельных объектов).\n\n---"
  popularity = 11.11

[[items]]
  id = 5
  question = "Основная идея языка"
  answer = "Написано однажды - работает везде\n\n---"
  popularity = 0.0

[[items]]
  id = 6
  question = "За счет чего обеспечена кроссплатформенность?"
  answer = "За счет создания виртуальной машины Java. Это что-то вроде прослойки между ОС и Java программой\n\n---"
  popularity = 0.4

[[items]]
  id = 7
  question = "Плюсы и минусы Java?"
  answer = "***Плюсы:***\n- **Объектно-ориентированное программирование.** Структура данных становится объектом, которым можно управлять, создавать отношения между различными объектами.\n\n- **Язык высокого уровня с простым синтаксисом и плавной кривой обучения.** Синтаксис Java основан на C ++, поэтому Java похожа на C. Тем не менее, синтаксис Java проще, что позволяет новичкам быстрее учиться и эффективнее использовать код для достижения конкретных результатов.\n- **Стандарт для корпоративных вычислительных систем.**  Корпоративные приложения — главное преимущество Java с 90-х годов, когда организации начали искать надежные инструменты программирования не на C.\n- **Безопасность.**  Благодаря отсутствию указателей и Security Manager (политика безопасности, в которой можно указать правила доступа, позволяет запускать приложения Java в \"песочнице\").\n- **Независимость от платформы.**  Можно создать Java-приложение на Windows, скомпилировать его в байт-код и запустить его на любой другой платформе, поддерживающей виртуальную машину Java (JVM). Таким образом, JVM служит уровнем абстракции между кодом и оборудованием.\n- **Язык для распределенного программирования и комфортной удаленной совместной работы.**   Специфическая для Java методология распределенных вычислений называется Remote Method Invocation (RMI). RMI позволяет использовать все преимущества Java: безопасность, независимость от платформы и объектно-ориентированное программирование для распределенных вычислений. Кроме того, Java также поддерживает программирование сокетов и методологию распределения CORBA для обмена объектами между программами, написанными на разных языках.\n- **Автоматическое управление памятью.** (вопрос спорный: плюс или минус) Разработчикам Java не нужно вручную писать код для управления памятью благодаря автоматическому управлению памятью (AMM).\n- **Многопоточность.** Поток — наименьшая единица обработки в программировании. Чтобы максимально эффективно использовать время процессора, Java позволяет запускать потоки одновременно, что называется многопоточностью.\n- **Стабильность и сообщество.**  Сообщество разработчиков Java не имеет себе равных. Около 45% респондентов опроса StackOverflow 2018 используют Java.\n\n***Минусы:***\n- Платное коммерческое использование (с 2019)\n- Многословный код\n\n---"
  popularity = 0.0

[[items]]
  id = 8
  question = "JVM, JRE, JDK, JIT"
  answer = "- **JVM** - Виртуальная машина Java, которая исполняет байт-код\n- **JRE** - Среда выполнения Java. Включает в себя JVM и стандартные библиотеки классов \n  - java.lang - String, System, Object\n  - java.io - InputStream, OutputStream\n  - java.util - коллекции (List, Set, Map)\n- **JDK** - Набор инструментов для разработки. Включает в себя JRE, компилятор и другие утилиты\n- **JIT** - компиляция байт-кода в машинный во время выполнения программы\n\n---"
  popularity = 2.38

[[items]]
  id = 9
  question = "Что такое байт-код?"
  answer = "Набор инструкций исполняемый виртуальной машиной Java\n\n---"
  popularity = 0.79

[[items]]
  id = 10
  question = "Что такое сборщик мусора (garbage collector)?"
  answer = "В Java используется автоматическое управление памятью. Программист выделяет память, а за освобождение отвечает JVM. Когда программа больше не ссылается на объект (прямые или косвенные ссылки), то объект удаляется, а память переиспользуется. Сборщик мусора – это демон-поток, который выполняет две задачи:\n1. поиск \n2. очистка мусора.\n\n---\n***Вызов сборщика мусора сейчас?*** \n- system.gc()\n\n---\n***Разница между GC в разных версиях Java***\n\n| **Версия Java** | **GC по умолчанию** | **Примечания**                                              |\n|-----------------|---------------------|-------------------------------------------------------------|\n| Java 8          | \tParallel GC        | \tОптимизирован для пропускной способности.                  |\n| Java 9          | \tG1                 | \tG1 стал сборщиком по умолчанию, заменив Parallel GC.       |\n| Java 10         | \tG1                 | \tУлучшения в G1, включая параллельную полную сборку мусора. |\n| Java 11         | \tG1                 | \tВведены ZGC и Shenandoah (экспериментальные).              |\n| Java 12         | \tG1                 | \tУлучшения в G1, включая возврат неиспользуемой памяти.     |\n| Java 13         | \tG1                 | \tУлучшения в ZGC и Shenandoah.                              |\n| Java 14         | \tG1                 | \tZGC и Shenandoah стали стабильными.                        |\n| Java 15         | \tG1                 | \tZGC стал кроссплатформенным.                               |\n| Java 16         | \tG1                 | \tУлучшения в ZGC и Shenandoah.                              |\n| Java 17         | \tG1                 | \tCMS окончательно удален.                                   |\n| Java 21         | \tG1                 | \tВведен Generational ZGC, улучшения в G1, ZGC и Shenandoah. |\n\n***Когда использовать другие GC?***\n\n* *ZGC*: Для приложений с огромными кучами (терабайты) и требованиями к минимальным паузам (менее 10 мс).\n* *Shenandoah*: Для приложений с низкими задержками и большими кучами.\n* *Parallel GC*: Для приложений, где важна пропускная способность, а не низкие задержки.\n* *Serial GC*: Для однопоточных приложений или приложений с небольшими кучами.\n\n---"
  popularity = 8.33

[[items]]
  id = 11
  question = "Как работает GC?"
  answer = "1. Поиск недостижимых объектов: Проверяет, есть ли ссылки на объект.\n2. Очистка: Если объект недостижим, его память освобождается.\n3. Обновление памяти: Освобождённая память становится доступной для новых объектов.\n\nОсновные алгоритмы GC:\n\n- Mark-and-Sweep: Отмечает используемые объекты и удаляет неиспользуемые.\n- Generational GC: Разделяет память на молодое, старшее и постоянное поколение для оптимизации работы.\n\n---"
  popularity = 14.68

[[items]]
  id = 12
  question = "Какие виды GC знаешь?"
  answer = "1. Serial GC: Подходит для небольших приложений (однопоточный).\n2. Parallel GC: Использует несколько потоков, подходящий для многопоточных приложений.\n3. CMS (Concurrent Mark-Sweep): Быстрый сбор мусора, минимизирует паузы.\n4. G1 GC (Garbage First): Балансирует между производительностью и паузами.\n5. ZGC: Для приложений с низкими паузами, работающими с большим объёмом памяти.\n6. Shenandoah GC: Минимизирует паузы сборщика мусора.\n\n---"
  popularity = 6.75

[[items]]
  id = 13
  question = "Области памяти Java. Stack и heap. Что это такое?"
  answer = ""
  popularity = 17.06

[[items]]
  id = 14
  question = "Типы данных в Java"
  answer = "В Java есть примитивные и ссылочные типы данных.\n\n**Примитивные типы данных:**\n- byte (0) (8 бит)\n- short (0) (16 бит)\n- int (0) (32 бит)\n- long (0L) (64 бит)\n- float (0.0f) (32 бит)\n- double (0.0d) (64 бит)\n- char (\\u0000) (16 бит)\n- boolean (false) (зависит от JVM)\n\n---"
  popularity = 1.19

[[items]]
  id = 15
  question = "Что такое класс-обертка?"
  answer = "Классы-обёртки - это специальные immutable-классы, которые представляют примитивные типы данных в виде объектов. Они позволяют хранить null, в отличие от примитивов, при работе с которыми null вызывает NullPointerException. Обёртки содержат полезные статические поля (MIN_VALUE, MAX_VALUE)  упрощающие работу с данными.\n\n---"
  popularity = 3.17

[[items]]
  id = 16
  question = "Автоупаковка и автораспаковка"
  answer = "- Автоупаковка - примитивный тип ⇒ объектный класс\n- Автораспаковка - объектный класс ⇒ примитивный тип\n\n---"
  popularity = 0.4

[[items]]
  id = 17
  question = "Строки/String в Java? Из чего состоит? Нюансы"
  answer = ""
  popularity = 7.14

[[items]]
  id = 18
  question = "Что такое пул строк/String pool?"
  answer = "Пул строк — это особая область кучи (heap), где хранятся объекты строк. Служит в первую очередь для оптимизации работы со строковыми литералами. При объявлении литерала (строки в двойных кавычках) в пуле происходит поиск этой строки:\n- Если такой строки в пуле нет ⇒ создается строка, возвращается ссылка\n- Если есть ⇒ возвращается ссылка найденной строки  \n\nСтроки, созданные с помощью `new String()` не помещаются в пул строк и хранятся в куче как остальные объекты.\n\n---\n***Что делает метод intern() в классе String?***\n- Помещает строку в пул строк\n\n---"
  popularity = 9.13

[[items]]
  id = 19
  question = "Почему не рекомендуется изменять строки в цикле?"
  answer = "Строка является неизменной и финализированной в Java, поэтому все наши манипуляции со строкой всегда будут создавать новую строку. Манипуляции со строками ресурсоемкие, поэтому Java обеспечивает два полезных класса для манипуляций со строками – **StringBuffer** и **StringBuilder**.\n\n---"
  popularity = 0.4

[[items]]
  id = 20
  question = "Разница между String, StringBuffer, StringBuilder"
  answer = "- **String** - неизменяемый, потокобезопасный\n- **StringBuffer** - изменяемый, потокобезопасный\n- **StringBuilder** - изменяемый, потоко**НЕ**безопасный\n\n---"
  popularity = 4.76

[[items]]
  id = 21
  question = "Каким образом переменные передаются в методы — по значению или по ссылке?"
  answer = "По значению. Всегда\n\n---"
  popularity = 1.98

[[items]]
  id = 22
  question = "Что такое enum?"
  answer = "Enum - набор логически связанных констант. Нужны для ограничения области допустимых значений (времена года, дни недели)\n\n---"
  popularity = 0.79

[[items]]
  id = 23
  question = "Что такое конструктор?"
  answer = "Конструкторы в Java представляют собой специальный блок кода, похожий на метод, предназначенный для инициализации полей объекта при его создании. Он вызывается всегда, когда создается новый экземпляр класса.\n\n---\n***Конструктор по умолчанию***\n  \nЕсли у класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый “конструктор по умолчанию”\n\n---\n***Для чего нужны приватные/private конструкторы?***\nПриватный конструктор запрещает создание экземпляра класса вне методов самого класса. Нужен для реализации паттернов `singleton`\n\n```java\npublic class Singleton {\n    // Статическое поле для хранения единственного экземпляра класса\n    private static Singleton instance;\n\n    // Приватный конструктор, предотвращающий создание экземпляров извне\n    private Singleton() {}\n\n    // Публичный метод для доступа к единственному экземпляру класса\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n---\n***Чем отличаются конструкторы по умолчанию, конструктор копирования и конструктор с параметрами?***\n- Конструктор по умолчанию. Отсутствуют какие-либо параметры\n- Конструктор копирования. Принимает в качестве аргумента уже существующий объект класса для последующего создания его клона\n- Конструктор с параметрами имеет в своей сигнатуре аргументы\n\n---"
  popularity = 1.59

[[items]]
  id = 24
  question = "Какие есть модификаторы доступа? Какие применимы к классам?"
  answer = "- `private`. Доступ только из класса, в котором объявлен\n- `default`. Переменная доступна для любого другого класса в том же пакете\n- `protected`. Переменная доступна всем классам внутри пакета, а так же всем классам-наследникам вне пакета\n- `public`. Доступ к компоненту из любой точки программы\n\n---"
  popularity = 3.17

[[items]]
  id = 25
  question = "Что означает static?"
  answer = "- `static` переменная - переменная, принадлежащая классу, а не объекту\n- `static` класс - вложенный класс, который может обращаться только к статическим полям класса-обертки\n- `static` метод - метод, принадлежащий классу, а не объекту. Статические методы обращаются только к другим статическим методам и переменным\n\n---\n***Может ли статический метод быть переопределен?***\n\nНельзя переопределять статические методы.\nЕсли объявить такой же метод в классе-наследнике, то мы лишь «спрячем» метод суперкласса вместо переопределения. Это называется сокрытие методов.\n\n> *Прим.* Перегружать можно, переопределять нет. В случае со статическими методами это не переопределение (overriding), а сокрытие (hiding).\n\n---\n***Могут ли нестатические методы перегружать статические?***\n\nДа. В итоге получится два разных метода. \nСтатический будет принадлежать классу и будет доступен через его имя, а нестатический будет принадлежать конкретному объекту и доступен через вызов метода этого объекта.\n\n---\n***Могут ли классы быть статическими?***\n\nДа, вложенные классы\n\n---"
  popularity = 5.56

[[items]]
  id = 26
  question = "Можно ли сузить уровень доступа или тип возвращаемого значения при переопределении метода?"
  answer = "Можно расширить модификатор доступа и сузить тип возвращаемого значения (если они совместимы)\n\n---"
  popularity = 0.4

[[items]]
  id = 27
  question = "Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и т. п.)?"
  answer = ""
  popularity = 0.4

[[items]]
  id = 28
  question = "Что означает модификатор final? К чему он может быть применим?"
  answer = "- `final` у класса. Запрещает наследование\n- `final` у метода. Запрещает переопределять данный метод в наследниках класса\n- `final` у примитива. Запрещает изменение значения после присвоения\n- `final` у ссылочной переменной. Запрещает изменение ссылки на объект\n- `final` у массива. Запрещает изменение ссылки на массив (но можно менять элементы внутри)\n\n---"
  popularity = 8.33

[[items]]
  id = 29
  question = "Что такое абстрактные классы?"
  answer = "Абстрактным классом называется класс, у которого не может быть экземпляров. Может содержать абстрактные методы. Наследниками абстрактного класса могут быть другие абстрактные классы и обычные классы\n\n---\n***Может ли быть абстрактный класс без абстрактных методов?***\n\nДа, может\n\n---\n***Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?***\n\nДа, могут, если они нужны для наследников\n\n---"
  popularity = 2.38

[[items]]
  id = 30
  question = "Что такое интерфейсы?"
  answer = "Интерфейс — это особый абстрактный тип, описывающий поведение (контракт), которое  классы должны реализовать\n- Методы интерфейса - public abstract\n- Поля - public static final\n\n---\n***Какие модификаторы по умолчанию/по дефолту имеют поля и методы интерфейсов?***\n\nDefault методы - это методы в интерфейсе, которые имеют тело и помечены `default`. Классы, реализующие такой интерфейс могут не переопределять метод и использовать код из интерфейса.\n\nНачиная с Java 8 в интерфейсах разрешается размещать реализацию методов по умолчанию `default` и статических `static` методов.\n\nПо умолчанию все методы в интерфейсе фактически имеют модификатор `public`. Однако начиная с Java 9 мы также можем определять в интерфейсе методы с модификатором `private`. Они могут быть статическими и нестатическими, но обязаны иметь реализацию (т.е. тело метода).\n\nИнтерфейс также может содержать и поля. В этом случае они автоматически являются публичными `public`, статическими `static` и неизменяемыми `final`.\n\n---\n***Может ли один интерфейс наследоваться от другого? От двух других?***\n\nДа\n\n---\n***Зачем нужны интерфейсы маркеры?***\n\nИнтерфейсы-маркеры (marker interfaces) — это интерфейсы без методов, используемые для предоставления метаинформации о классе.\n\n**Примеры:**\n\n`Serializable` — сообщает, что объект может быть сериализован.  \n`Cloneable` — разрешает создание копий объекта через clone().  \n\n**Плюсы:**  \n✅ Простота реализации.  \n✅ Используется в стандартной библиотеке Java (Serializable, Cloneable).  \n✅ Позволяет использовать instanceof для проверки типа.  \n\n**Минусы:**  \n❌ Неявная логика — тяжело понять, что делает интерфейс.  \n❌ Сложно поддерживать, если нужно добавить новую функциональность.  \n❌ Нельзя контролировать правильность использования (например, Cloneable не гарантирует корректную реализацию clone()).\n\n---\n***Плюсы и минусы дефолтных методов***\n\n**`default`-методы** позволяют добавлять реализацию методов в интерфейсы без необходимости изменять существующие реализации классов.\n\n**Пример:**\n\n```java\ninterface Animal {\n    default void makeSound() {\n        System.out.println(\"Some sound...\");\n    }\n}\nclass Dog implements Animal {}\npublic class Main {\n    public static void main(String[] args) {\n        Dog dog = new Dog();\n        dog.makeSound(); // Выведет \"Some sound...\"\n    }\n}\n```\n\n**Плюсы:**  \n✅ Позволяют добавлять новые методы в интерфейсы без ломания существующего кода.  \n✅ Уменьшают дублирование кода в классах, реализующих интерфейс.  \n✅ Можно предоставлять базовую реализацию метода.\n\n**Минусы:**  \n❌ Может усложнять иерархию классов, если использовать слишком активно.  \n❌ Конфликты `default`-методов, если несколько интерфейсов содержат метод с одинаковой сигнатурой.    \n❌ Нарушает принцип единственной ответственности (SRP), так как интерфейс начинает содержать логику.\n\n---\n***Плюсы и минусы множественной имплементации***\n\nМножественная имплементация означает, что класс может реализовать несколько интерфейсов.\n\n**Пример:**\n\n```java\ninterface A {\n    default void show() {\n        System.out.println(\"A\");\n    }\n}\ninterface B {\n    default void show() {\n        System.out.println(\"B\");\n    }\n}\nclass C implements A, B {\n    @Override\n    public void show() {  // Разрешаем конфликт\n        A.super.show();\n    }\n}\n```\n\n**Плюсы:**  \n✅ Позволяет избежать проблем, связанных с множественным наследованием (алмазная проблема).  \n✅ Повторное использование кода через `default`-методы.  \n✅ Гибкость — можно комбинировать поведение разных интерфейсов.\n\n**Минусы:**  \n❌ Конфликты `default`-методов, если несколько интерфейсов содержат метод с одинаковой сигнатурой.  \n❌ Возможна сложность в отладке и поддержке кода.  \n❌ Нельзя использовать `super` для вызова конструктора интерфейса.\n\n---"
  popularity = 1.98

[[items]]
  id = 31
  question = "Отличия интерфейса от абстрактных классов?"
  answer = "- Абстрактные классы используются, когда есть отношение ‘is a’, а интерфейс может быть реализован классами, вовсе не связанными друг с другом\n- Унаследовать можно только один класс, а реализовать интерфейсов — сколько угодно \n\n|**Критерий**|**Абстрактный класс**|**Интерфейс**|\n|---|---|---|\n|**Когда использовать**|Если есть общая логика, которую наследники могут переопределять|Для определения контрактов, которые реализуют классы|\n|**Модификаторы доступа по умолчанию**|`protected`, `default`|Все методы `public`|\n|**Наличие конструктора**|Да|Нет|\n|**Наследование/реализация**|Класс может наследовать только один абстрактный класс|Класс может реализовать несколько интерфейсов|\n|**Методы с реализацией**|Может содержать методы с реализацией|С Java 8: может содержать `default` методы с реализацией|\n\n---"
  popularity = 14.29

[[items]]
  id = 32
  question = "Каков порядок вызова конструкторов и блоков инициализации с учетом иерархии классов?"
  answer = ""
  popularity = 1.98

[[items]]
  id = 33
  question = "Зачем нужны и какие бывают блоки инициализации?"
  answer = "Существуют статические и нестатические блоки инициализации.  \n**Статический блок инициализации** используется для инициализации статических данных класса. Он выполняется только один раз, когда класс загружается в память.  \n**Нестатический блок инициализации**, также известный как блок инициализации экземпляра, используется для инициализации переменных экземпляра класса. Он выполняется каждый раз, когда создается новый экземпляр класса.\n\n---"
  popularity = 0.4

[[items]]
  id = 34
  question = "Для чего в Java используются статические блоки инициализации?"
  answer = "Статический блок инициализации используется для инициализации статических данных класса. Он выполняется только один раз, когда класс загружается в память.  \n\n---"
  popularity = 0.4

[[items]]
  id = 35
  question = "Класс Object и его методы?"
  answer = "Object - базовый класс для всех объектов в Java. Любой класс так или иначе наследуется от `Object`, и, соответственно, наследует его методы (11 штук):\n- `equals()` - определяет, равен ли один объект другому.\n- `hashCode()` - возвращает хэш-код, связанный с вызывающим объектом.\n- `toString()` - возвращает символьную строку, описывающую объект.\n- `getClass()` - получает класс объекта во время выполнения.\n- `clone()` - создает новый объект, не отличающийся от клонируемого.\n- `finalize()` - вызывается перед удалением неиспользуемого объекта.\n\nА так же методы для многопоточности:\n- `notify()` - возобновляет исполнение потока, ожидающего вызывающего объекта.\n- `notifyAll()` - возобновляет исполнение всех потоков, ожидающих вызывающего объекта.\n- `wait()`, `wait(long timeout)`, `wait(long timeout, int nanos)` - ожидает другого потока исполнения.\n\n---\n***Метод finalize()***\n\n`finalize()` — это метод в классе `Object`, который вызывается перед уничтожением объекта сборщиком мусора (GC). Помечен как `@Deprecated` с Java 9 с возможностью дальнейшего удаления.\n\n**Пример использования:**\n\n```java\nclass Resource {\n    @Override\n    protected void finalize() throws Throwable {\n        System.out.println(\"Объект удаляется\");\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        new Resource();\n        System.gc(); // Запрос на сборку мусора\n    }\n}\n```\n\n**Плюсы `finalize()`:**  \n✅ Можно освободить ресурсы перед удалением объекта.\n\n**Минусы `finalize()`:**  \n❌ Не гарантируется, что `finalize()` вызовется своевременно.  \n❌ Сложно отлаживать, так как GC работает асинхронно.  \n❌ Медленный — лучше использовать `try-with-resources` или `close()`.\n\n**Современная альтернатива:**  \nJava 9+: использовать `Cleaner` или `try-with-resources`.\n\n---"
  popularity = 4.76

[[items]]
  id = 36
  question = "Что такое сериализация и для чего она нужна?"
  answer = "Сериализация - это процесс сохранения объекта в последовательность байт. Реализована через интерфейс-маркер Serializable. Нужна для компактного сохранения состояния объекта и считывания этого состояния\n\n---"
  popularity = 1.19

[[items]]
  id = 37
  question = "Разница между версиями Java"
  answer = "- **Java 8**: Лямбда-выражения, Stream API, Optional API, новый Date and Time API, `default` методы в интерфейсах.\n- **Java 9**: Модульная система (JPMS), улучшения в Stream API и методы `Optional.ifPresentOrElse`, фабричные методы для коллекций (`List.of`).\n- **Java 10**: Локальная типизация (`var`), улучшения в GC, API для создания неизменяемых коллекций (`List.copyOf, Set.copyOf, Map.copyOf`)\n- **Java 11**: Поддержка `var` в лямбдах, новый клиент HTTP.\n- **Java 17**: `Record`, `sealed` классы, улучшения в GC и performance, pattern matching для `instanceof`.\n- **Java 21**: Virtual threads, pattern matching для `switch`, поддержка sealed-иерархий для `record`, улучшения в GC\n\n---"
  popularity = 0.4

[[items]]
  id = 38
  question = "Может ли абстрактный класс быть final?"
  answer = "Нет. Ключевое слово final запрещает наследование класса, а абстрактный класс предназначен для наследования.\n\n---"
  popularity = 0.4

[[items]]
  id = 39
  question = "Integer pool"
  answer = "Integer Pool — это кеширование объектов типа Integer в диапазоне от -128 до 127 для уменьшения количества создаваемых объектов.\n\n---"
  popularity = 1.59

[[items]]
  id = 40
  question = "Какие виды загрузчиков классов ты знаешь?"
  answer = "- **Bootstrap ClassLoader**: Загружает стандартные библиотеки (например, `rt.jar`).\n- **Extension ClassLoader**: Загружает дополнительные библиотеки (`ext`).\n- **System ClassLoader**: Загружает классы из classpath.\n- **Custom ClassLoader**: Пользовательские загрузчики классов.\n\n---"
  popularity = 0.4

[[items]]
  id = 41
  question = "Record-ы с Java 17. Для чего и зачем?"
  answer = ""
  popularity = 1.59

[[items]]
  id = 42
  question = "Что такое Анонимный класс"
  answer = "*Анонимный класс* — это класс без имени, который создаётся и используется \"на месте\".\n\n```java\nRunnable r = new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"Hello!\");\n    }\n};\n\n```\n\n---\n***Требования к переменным, на которые ссылаемся внутри анонимного класса***\n\nПеременные, используемые внутри анонимного класса, должны быть **effectively final** (не изменяться после инициализации).\n\n---"
  popularity = 1.59

[[items]]
  id = 43
  question = "Расскажи что делает JIT компилятор"
  answer = "JIT (Just-In-Time) компилятор преобразует байт-код в машинный код во время выполнения программы для повышения производительности. \n\n---"
  popularity = 1.98

[[items]]
  id = 44
  question = "Расскажи про прогрев JVM"
  answer = "**Прогрев JVM** — это процесс оптимизации приложения, когда JIT анализирует исполняемый код и применяет оптимизации, такие как инлайнинг или устранение лишних проверок.\n\n---"
  popularity = 0.4

[[items]]
  id = 45
  question = "break vs continue в цикле"
  answer = "- **`break`**: Завершает выполнение текущего цикла.\n- **`continue`**: Пропускает текущую итерацию цикла и переходит к следующей.\n\n---"
  popularity = 0.79

[[items]]
  id = 46
  question = "Что такое аннотация? Зачем нужна? Как создать свою аннотацию?"
  answer = "Аннотации в Java — это специальный механизм, который позволяет добавлять метаданные к коду (классам, методам, полям и т. д.). Они не изменяют поведение кода напрямую, но активно используются компилятором, инструментами разработки и фреймворками.\n\n**Основные аннотации в Java**  \n\n\n| Аннотация      | Описание |\n|---------------|----------|\n| `@Override`   | Проверяет, что метод переопределяет метод суперкласса. |\n| `@Deprecated` | Отмечает метод/класс устаревшим, чтобы не использовать его в будущем. |\n| `@SuppressWarnings` | Подавляет определенные предупреждения компилятора. |\n| `@FunctionalInterface` | Показывает, что интерфейс является функциональным (с одним абстрактным методом). |\n| `@SafeVarargs` | Подавляет предупреждения о небезопасных операциях с аргументами переменной длины (varargs). |\n| `@Native` | Используется для констант, предназначенных для взаимодействия с нативным кодом. |\n\n**Примеры встроенных аннотаций**  \n\n```java\nclass Parent {\n    void display() {}\n}\n\nclass Child extends Parent {\n    @Override  // Компилятор проверит, что метод действительно переопределяет родительский.\n    void display() {\n        System.out.println(\"Переопределенный метод\");\n    }\n\n    @Deprecated  // Компилятор выдаст предупреждение, если этот метод будет использоваться.\n    void oldMethod() {\n        System.out.println(\"Устаревший метод\");\n    }\n\n    @SuppressWarnings(\"unchecked\")  // Подавляет предупреждения о небезопасных операциях.\n    void uncheckedMethod() {\n        System.out.println(\"Небезопасная операция\");\n    }\n}\n```\n\n---\n\n**Метаданные аннотаций (`Retention`, `Target`)**  \nКогда мы создаем свою аннотацию, важно понимать, как она будет использоваться. Это задается с помощью **мета-аннотаций**:\n\n| Аннотация | Описание |\n|-----------|----------|\n| `@Retention` | Определяет, на каком этапе жизненного цикла аннотация доступна (SOURCE, CLASS, RUNTIME). |\n| `@Target` | Указывает, к чему можно применять аннотацию (методы, поля, классы и т. д.). |\n| `@Documented` | Включает аннотацию в Javadoc. |\n| `@Inherited` | Наследуется ли аннотация подклассами. |\n| `@Repeatable` | Позволяет применять одну и ту же аннотацию несколько раз. |\n\n**Как создать свою аннотацию?**  \n\n```java\nimport java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface MyAnnotation {\n    String value();\n    int count() default 1;\n}\n\nclass Example {\n    @MyAnnotation(value = \"Hello\", count = 3)\n    public void test() {\n        System.out.println(\"Метод с аннотацией\");\n    }\n}\n```\n\n**Чтение аннотации с помощью рефлексии**  \n\n```java\nimport java.lang.reflect.Method;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Method method = Example.class.getMethod(\"test\");\n        MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);\n        System.out.println(\"value: \" + annotation.value());  // \"Hello\"\n        System.out.println(\"count: \" + annotation.count());  // 3\n    }\n}\n```\n\n**Где используются аннотации в реальных проектах?**  \n\n**Lombok (`@Getter`, `@Setter`)**  \n\nАвтоматически генерирует геттеры и сеттеры.\n\n```java\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Getter\n@Setter\nclass Person {\n    private String name;\n}\n```\n\n**Spring Boot (`@RestController`, `@Autowired`)**  \nИспользуется для конфигурирования компонентов.\n\n```java\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\npublic class MyController {\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello, world!\";\n    }\n}\n```\n\n**JUnit (`@Test`)**  \nПозволяет помечать методы как тесты.\n\n```java\nimport org.junit.jupiter.api.Test;\n\nclass MyTests {\n    @Test\n    void testSomething() {\n        System.out.println(\"Запуск теста\");\n    }\n}\n```\n\n---"
  popularity = 3.97

[[items]]
  id = 47
  question = "Переопределение и перегрузка методов"
  answer = "🔁 **Переопределение методов**\n\nЭто **изменение поведения метода**, унаследованного от родительского класса.\n\n 📌 Правила:\n\n- Метод должен иметь **точно такое же имя**, **тип возвращаемого значения** и **аргументы**.  \n- Метод в родительском классе **должен быть не private**.  \n- Должен происходить в **наследуемом классе**.   \n- Аннотация `@Override` **рекомендуется** (не обязательна, но помогает избежать ошибок).   \n\n 📦 Пример:\n\n```java\nclass Animal {\n    public void makeSound() {\n        System.out.println(\"Животное издает звук\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Собака лает 🐶\");\n    }\n}\n```\n\n 🧠 Что происходит:\n\nМетод `makeSound()` переопределён в классе `Dog`. При вызове на объекте типа `Dog` будет работать именно его версия.\n\n ➕ **Перегрузка методов (Overloading)**\n\nЭто когда в одном классе есть **несколько методов с одинаковым именем**, но **разными параметрами**.\n\n 📌 Правила:\n- Имена методов **одинаковые**.  \n- Различие — в **количестве**, **типах** или **порядке аргументов**.  \n- Возвращаемый тип **может быть любым**, но **не используется для различия перегрузки**.  \n\n 📦 Пример:\n\n```java\nclass Calculator {\n\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    public double add(double a, double b) {\n        return a + b;\n    }\n\n    public int add(int a, int b, int c) {\n        return a + b + c;\n    }\n}\n```\n\n 🧠 Что происходит:\n\nМетод `add()` перегружен — Java понимает, какой использовать, в зависимости от аргументов.\n\n---"
  popularity = 4.76

[[items]]
  id = 48
  question = "ClassLoader в Java"
  answer = "**ClassLoader** — это специальный компонент JVM, который отвечает за загрузку классов в память во время выполнения программы.  \nКогда ты пишешь `new MyClass()`, прежде чем создать объект, JVM должна найти файл `MyClass.class`, загрузить его в память и проинициализировать. Этим занимается ClassLoader.\n\nПредставь, что у тебя есть библиотека 📚. На полках лежат книги (это твои классы `.class`).  \nКогда тебе нужна книга, ты идёшь к библиотекарю (ClassLoader), и он:\n\n- находит её,\n- приносит в читальный зал (загружает в память),\n- ты начинаешь читать (использовать класс).\n\n\n**ClassLoader отвечает за то, чтобы класс оказался доступен программе тогда, когда он нужен**.\n\n🔹 **Как работает ClassLoader (иерархия)**\n\nВ Java есть несколько \"библиотекарей\" (загрузчиков), которые работают как цепочка:\n\n1. **Bootstrap ClassLoader** — главный библиотекарь.  \n   Он отвечает только за самые базовые книги, например «Алфавит» (классы `String`, `Object`, `Integer`).  \n   Если тебе нужна базовая вещь, он сам её выдаст.\n2. **Platform ClassLoader** — библиотекарь среднего уровня.  \n   Он занимается «дополнительной литературой», например модулями Java (`javax.*`, `java.sql.*`).\n3. **Application ClassLoader** — библиотекарь для твоих книг.  \n   Он приносит книги, которые ты написал сам или добавил через сторонние библиотеки (`target/classes`, `lib/*.jar`).\n\n\n🔹 **Принцип делегирования**\n\nКогда ты просишь книгу (класс), библиотекарь действует так:\n\n- Сначала идёт к **старшему библиотекарю** и спрашивает: «У тебя есть эта книга?»\n- Если есть — возвращает её.\n- Если нет — ищет сам.\n\n\n👉 Это сделано для того, чтобы не оказалось двух разных «книг» с названием **String**. Базовые классы всегда будут загружены только главным библиотекарем (Bootstrap).\n\n🔹 **Пример из жизни**\n\nПредставь университетскую библиотеку:\n\n- 📘 **Bootstrap ClassLoader** — это национальная библиотека. Она хранит фундаментальные книги, которые нужны всем (словарь, грамматика).\n- 📗 **Platform ClassLoader** — это университетская библиотека. Там есть специализированные книги для разных факультетов.\n- 📙 **Application ClassLoader** — это библиотека твоей кафедры. Там лежат твои учебники, методички и лекции.\n\nКогда студент просит книгу:\n\n1. Сначала проверяют в национальной библиотеке.\n2. Если там нет — смотрят в университетской.\n3. Если и там нет — идут в кафедральную.\n\n\n🔹 **Ключевые моменты**\n\n- **ClassLoader = библиотекарь**, который приносит нужные книги (классы) из хранилища в память.\n- Работает **цепочкой**: Bootstrap → Platform → Application.\n- Использует **делегирование** (сначала у старшего, потом сам).\n- Можно сделать **своего библиотекаря** (Custom ClassLoader) для особых случаев.\n   \n---"
  popularity = 3.57

[[items]]
  id = 49
  question = "В чем разница сравнений по equals и \"==\"?"
  answer = "`==` → сравнивает **ссылки** (адреса в памяти) для объектов, а для примитивов — **значения**.\n\n`.equals()` → сравнивает **содержимое** объектов (если метод переопределён).\n\nМетод `equals()` по умолчанию в `Object` делает то же, что `==`, но его часто переопределяют для сравнения содержимого объектов."
  popularity = 2.78
