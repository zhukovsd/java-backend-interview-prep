[section]
  id = 1
  title = "ООП"
  popularity = 10.31

[[items]]
  id = 1
  question = "Что такое ООП?"
  answer = "ООП - методология программирования, центральное место в которой занимает объект. Программа же в целом - совокупность объектов (экземпляров классов). Класс в свою очередь представляет собой шаблон и состоит из:\n\n- Полей\n- Конструктора\n- Методов"
  popularity = 2.29

[[items]]
  id = 2
  question = "Плюсы и минусы ООП"
  answer = "Плюсы:\n\n- Делим программу на «модули»-классы, ОБЪЕКТЫ каждый из которых делает свою часть работы.\n- Код можно повторно использовать в любом месте программы, это экономит время (не нужно писать однотипные функции для разных сущностей).\n- «Более естественная» декомпозиция ПО существенно облегчает его разработку (код легко читается и быстро пишется).\n- Возможность создавать расширяемые системы (extensible systems), именно это отличает ООП от традиционных методов программирования.\n\nМинусы:\n\n- Снижение производительности, увеличение потребности памяти (Информация распределяется на множество мелких инкапсулированных объектов ⇒ на них растет количество ссылок)"
  popularity = 0.0

[[items]]
  id = 3
  question = "Принципы ООП (наследование, инкапсуляция, полиморфизм, абстракция)"
  answer = " **Инкапсуляция** - объединение данных и методов, работающих с ними в одном классе, а так же сокрытие деталей реализации от пользователя. Очевидные примеры инкапсуляции - это: модификаторы доступа, getter-ы и setter-ы.\n\n **Наследование** - возможность порождать один класс от другого(родительского) с сохранением всех его свойств и методов, добавляя при необходимости новые свойства и методы\n\n **Полиморфизм** - это способность объектов одного типа вести себя как объекты других типов (обычно подклассов или реализуемых интерфейсов), что позволяет вызывать один и тот же метод через общий интерфейс, а реализация будет определяться во время выполнения программы\n  - **Динамическим** (`@Override`)\n    - Достигается переопределением методов в подклассах (@Override)\n    - Решение, какую версию метода вызвать, принимается во время выполнения программы\n\n```java\nclass Animal {\n    void sound() {\n        System.out.println(\"Some generic animal sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    void sound() {\n        System.out.println(\"Woof!\");\n    }\n}\n\nclass Cat extends Animal {\n    @Override\n    void sound() {\n        System.out.println(\"Meow!\");\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        Animal a1 = new Dog();\n        Animal a2 = new Cat();\n\n        a1.sound(); // Woof!\n        a2.sound(); // Meow!\n    }\n}\n\n```\n\nПеременная типа Animal может ссылаться на объект Dog или Cat, а метод sound() будет вызван в соответствии с реальным типом объекта в рантайме.\n\n  - **Статическим** (перегрузка)\n    - Достигается перегрузкой методов (method(int), method(String) и т. д.)\n    - Объединяет одно имя метода с разными параметрами\n\n```java\npublic class MathUtils {\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    public double add(double a, double b) {\n        return a + b;\n    }\n\n    public int add(int a, int b, int c) {\n        return a + b + c;\n    }\n}\n\n```\n\nЗдесь три метода add имеют одно имя, но разные сигнатуры — компилятор выбирает нужный при компиляции кода\n\n **Абстракция** – это способ выделить набор общих характеристик объекта, исключая из рассмотрения частные и незначимые. Соответственно, абстракция – это набор всех таких характеристик.\n"
  popularity = 9.92

[[items]]
  id = 4
  question = "Класс, объект, интерфейс"
  answer = " **Класс** – это описание ещё не созданного объекта, общий шаблон.\nШаблон состоит из:\n   - полей (имя, возраст для чел. и т.д.). Состояние/ряд меняющихся свойств.\n   - конструктора (первоначально инициализирует объект, заполняет нужные поля)\n   - методов (что умеет делать объект). Действия, функции конкретного объекта.\n  \n **Объект** – это экземпляр класса, созданный по шаблону (выше) с собственным состоянием свойств.\n\n **Интерфейс** — это абстрактный тип, который определяет контракт (набор методов), который должен реализовывать любой класс, подписавшийся на этот интерфейс. Интерфейсы позволяют задавать общие действия, которые могут выполнять различные классы, не завися от их конкретной реализации."
  popularity = 0.38

[[items]]
  id = 5
  question = "Ассоциация, агрегация, композиция"
  answer = " **Ассоциация** означает, что объекты двух классов могут ссылаться один на другой, иметь связь друг с другом. Один класс включает в себя другой класс в качестве одного из полей.\n\n>**Агрегация** и **композиция** являются частными случаями ассоциации. Это более конкретизированные отношения между объектами.\n\n **Композиция** — это более жёсткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежать кому-то.\n    (Страница принадлежит только одной Книге.)\n\n **Агрегация** — отношение, когда один объект является частью другого. \n    (Двигатель поставили в одну машину, потом в другую.)"
  popularity = 0.76

[[items]]
  id = 6
  question = "Статическое и динамическое связывание"
  answer = "**Связывание** - процесс, в ходе которого программа решает, какой метод или переменная должна быть вызвана или использована. Связывание бывает:\n  - Раннее статическое.  Если метод известен компилятору, то происходит на этапе компиляции. Применяется для дженериков, перегруженных, `private`, `final` и `static` методов. Используются не объекты, а информация о типе, то есть ссылка\n  -  Позднее динамическое. Происходит во время выполнения программы JVM. Используется для абстрактных и переопределенных методов\n "
  popularity = 1.15

[[items]]
  id = 7
  question = "Является – «is a», имеет – «has a»"
  answer = "  **Наследование** «is a» ЯВЛЯТЬСЯ (обобщение/расширение) – очень мощная связь\n\n  **Ассоциация** «has a» ИМЕТЬ (объекты ИМЕЮТ ссылки/ссылаются друг на друга)\n"
  popularity = 0.38
