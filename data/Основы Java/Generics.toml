[section]
  id = 7
  title = "Дженерики"
  popularity = 16.67

[[items]]
  id = 1
  question = "Что такое дженерики? Для чего нужны?"
  answer = "Дженерики - параметризованные типы в Java\n\n- Что это? Позволяют создавать классы, интерфейсы и методы с типами, заданными как параметры\n- Зачем нужны? Позволяют использовать один класс для разных типов данных (`List<String>`, `List<Integer>`)\n\nНабор [рекомендаций](https://docs.oracle.com/javase/tutorial/java/generics/types.html) от Oracle о том, когда какие обозначения лучше использовать в дженериках:\n* **E** — element, для элементов параметризованных коллекций;\n* **K** — key, для ключей map-структур;\n* **V** — value, для значений map-структур;\n* **N** — number, для чисел;\n* **T** — type, для обозначения типа параметра в произвольных классах;\n* **S, U, V** и так далее — применяются, когда в дженерик-классе несколько параметров.\n\n---"
  popularity = 7.94

[[items]]
  id = 2
  question = "Что такое сырые типы?"
  answer = "Сырые типы - это использование обобщенных классов без указания типов, т.е. изначально класс или интерфейс описали с использованием дженериков, но при создании объекта этого класса тип ему не передали.\n\n```java\nList rawList = new ArrayList();\nList<String> list = new ArrayList<>();\n\nrawList = list; // OK\nlist = rawList; // WARN - компилятор не знает какие типы данных хранит rawList, поэтому выдаст предупреждение\n```\n\n---"
  popularity = 0.0

[[items]]
  id = 3
  question = "Что такое вайлдкард"
  answer = "Вайлдкарды - это символ ‘?’, который используется для обозначения неизвестного типа в дженериках.\n\n---"
  popularity = 0.79

[[items]]
  id = 4
  question = "Расскажите про принцип PECS"
  answer = "- Producer. Используется для чтения (? extends T)\n- Consumer. Используется для добавления (? super T)\n- Оба действия. Использовать конкретный тип, а не wildcard\n\n|           | Инвариантный `List<Type>`  | Ковариантный `List<? extends Type>` (Producer Extends) | Контрвариантный `List<? super Type>` (Consumer Super) |\n|-----------|----------------------------|--------------------------------------------------------|-------------------------------------------------------|\n| Присвоить | только `Type`              | `Type` и наследников `Type`                            | `Type` и родителей `Type`                             |\n| Читать    | `Type` и родителей `Type`  | `Type` и родителей `Type`                              | `Object`                                              |\n| Добавлять | `Type` и наследники `Type` | Ничего                                                 | `Type` и наследников `Type`                           |\n\n---"
  popularity = 4.76

[[items]]
  id = 5
  question = "Расскажите про класс Optional"
  answer = "Optional - Класс-обертка. Он помогает избежать ошибок, связанных с null\n\n---\n***Что делает Optional.flatMap()***\n\n`Optional.flatMap()` используется для работы с вложенными объектами `Optional`, помогая избежать двойной обёртки.\n\n```java\nOptional<String> getNestedValue(Optional<Optional<String>> nestedOpt) {\n    return nestedOpt.flatMap(opt -> opt);\n}\n\n```\n- Убирает вложенность: из `Optional<Optional<T>>` превращает в `Optional<T>`.\n\nИспользуйте `map`, если функция возвращает нужный вам объект, или `flatMap`, если функция возвращает `Optional` объект.\n\n---"
  popularity = 5.16

[[items]]
  id = 6
  question = "Как JVM работает с Generics"
  answer = "- JVM не хранит информацию о параметризованных типах в рантайме.\n- Компилятор стирает информацию о типе, заменяя все параметры без ограничений (*unbounded*) типом `Object`, а параметры с границами (*bounded*) — на эти границы.\n\n---\n***Что такое стирание типов?***\n\n**Стирание типов (Type Erasure)** — процесс, при котором компилятор стирает информацию о типе, заменяя все параметры без ограничений (*unbounded*)\nтипом `Object`, а параметры с границами (*bounded*) — на эти границы. Это делается для обеспечения обратной совместимости с кодом, написанным до появления дженериков в Java 5.\nСтирание состоит из трех действий:\n- Если параметры ограничены (*bounded*), вместо типа-параметра в местах использования подставляется верхняя граница, иначе `Object`.\n- В местах присвоения значения типа-параметра в переменную обычного типа компилятор автоматически добавляет приведение типов (*casting*).\n- Для поддержки полиморфизма компилятор создает мостовые методы (*bridge methods*) в случае, если дженерик используются в наследовании.\n\n---\n***Generics. Можно ли получить тип в рантайме?***\n\nНет, в общем случае нельзя. В Java используется **стирание типов** (`Type Erasure`), что означает, что информация о параметризованных типах удаляется после\nкомпиляции. \n\n**Исключения:** \n- Дженерик с wildcard без ограничений, например List<?> будет считаться List<Object>.\n- Можно сохранить информацию о типах с помощью рефлексии или через использование классов-обёрток.\n\nПример с `TypeToken`:\n```java\nimport java.lang.reflect.Type;\nimport com.google.gson.reflect.TypeToken;\n\nType type = new TypeToken<List<String>>(){}.getType();\nSystem.out.println(type); // java.util.List<java.lang.String>\n```"
  popularity = 3.57
